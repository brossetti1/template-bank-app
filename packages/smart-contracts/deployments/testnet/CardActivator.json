{
  "address": "0x7ca4963B90b32A7FABc9C3feF0bAD5C352892f48",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "admin",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_erc721KInstance",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_erc721KDesignInstance",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "activate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "color",
          "type": "uint8"
        },
        {
          "internalType": "uint8",
          "name": "emoji",
          "type": "uint8"
        }
      ],
      "name": "activateWithStyle",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "erc721KDesignInstance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "erc721KInstance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "release",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "setStyleUpgradeCost",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0xcbbe79e38ba5164af7e8c7b6b55285113845b8d0182c3a3726da5bcc0d00b11a",
  "receipt": {
    "to": null,
    "from": "0x8C46e53dC60EC32e8DD67Fb11f076fF3EcDc5211",
    "contractAddress": "0x7ca4963B90b32A7FABc9C3feF0bAD5C352892f48",
    "transactionIndex": 31,
    "gasUsed": "477899",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000100000100000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000410000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000020000000000000",
    "blockHash": "0x73426b627b6bed550f840b0849427a4636d4b981db2899023e2f237a34d91742",
    "transactionHash": "0xcbbe79e38ba5164af7e8c7b6b55285113845b8d0182c3a3726da5bcc0d00b11a",
    "logs": [
      {
        "transactionIndex": 31,
        "blockNumber": 3472119,
        "transactionHash": "0xcbbe79e38ba5164af7e8c7b6b55285113845b8d0182c3a3726da5bcc0d00b11a",
        "address": "0x7ca4963B90b32A7FABc9C3feF0bAD5C352892f48",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000761d584f1c2d43cbc3f42ecd739701a36dffaa31"
        ],
        "data": "0x",
        "logIndex": 39,
        "blockHash": "0x73426b627b6bed550f840b0849427a4636d4b981db2899023e2f237a34d91742"
      }
    ],
    "blockNumber": 3472119,
    "cumulativeGasUsed": "2904413",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x761d584f1C2d43cBc3F42ECd739701a36dFFAa31",
    "0xE4F669807D3CDdD24Cc5fF7F5AC8B3878545f844",
    "0xbA8B29723E1123CC5F48F0F933BE1D4C98e0D78E"
  ],
  "numDeployments": 1,
  "solcInputHash": "404f5463dd6ebc8ff1a6e382af5684f3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc721KInstance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc721KDesignInstance\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"color\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"emoji\",\"type\":\"uint8\"}],\"name\":\"activateWithStyle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc721KDesignInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc721KInstance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setStyleUpgradeCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"errors\":{\"Unauthorized()\":[{\"notice\":\"----------------------------------------------------------------------- Custom Errors -----------------------------------------------------------------------\"}]},\"events\":{\"OwnershipTransferred(address,address)\":{\"notice\":\"----------------------------------------------------------------------- Events -----------------------------------------------------------------------\"}},\"kind\":\"user\",\"methods\":{\"owner()\":{\"notice\":\"----------------------------------------------------------------------- Ownership Storage -----------------------------------------------------------------------\"},\"transferOwnership(address)\":{\"notice\":\"----------------------------------------------------------------------- Ownership Logic -----------------------------------------------------------------------\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/CardActivator.sol\":\"CardActivator\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"contracts/Card.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC20TWAB } from \\\"./PoolTogether/ERC20TWAB.sol\\\";\\nimport { ISVGRender } from \\\"./ERC721K/interfaces/ISVGRender.sol\\\";\\nimport { ERC721K } from \\\"./ERC721K/ERC721K.sol\\\";\\nimport { ERC721Storage } from \\\"./ERC721K/ERC721Storage.sol\\\";\\nimport { CardStorage } from \\\"./CardStorage.sol\\\";\\n\\ncontract Card is ERC721K {\\n  uint256 private immutable CONTROLLER_ROLE = 1e18;\\n\\n  mapping(address => uint256) private _belongsTo;\\n\\n  constructor(\\n    string memory name,\\n    string memory symbol,\\n    address erc721Storage\\n  ) ERC721K(name, symbol, erc721Storage) {\\n    _idCounter++;\\n  }\\n\\n  /* ===================================================================================== */\\n  /* Override Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function supportsInterface(bytes4 interfaceId)\\n    public\\n    view\\n    virtual\\n    override(ERC721K)\\n    returns (bool)\\n  {\\n    return super.supportsInterface(interfaceId);\\n  }\\n\\n  function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n    address owner = _ownerOf[tokenId];\\n    if (owner == address(0)) {\\n      return address(0);\\n    }\\n    return owner;\\n  }\\n\\n  function belongsTo(address account) public view virtual returns (uint256) {\\n    return _belongsTo[account];\\n  }\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  // --------------------------------------\\n  // READS\\n  // --------------------------------------\\n\\n  function preview(address account) external view returns (string memory) {\\n    bytes memory imageBytes = CardStorage(_erc721Storage).getPreview(account);\\n    return ISVGRender(ERC721Storage(_erc721Storage).getERC721KRender()).render(imageBytes);\\n  }\\n\\n  function previewWithStyle(\\n    address account,\\n    uint8 color,\\n    uint8 emoji\\n  ) external view returns (string memory) {\\n    bytes memory imageBytes = CardStorage(_erc721Storage).getPreviewWithStyle(\\n      account,\\n      color,\\n      emoji\\n    );\\n    return ISVGRender(ERC721Storage(_erc721Storage).getERC72KTraits()).render(imageBytes);\\n  }\\n\\n  // --------------------------------------\\n  // WRITES\\n  // --------------------------------------\\n\\n  /**\\n   * @notice Mints a new token to the given address\\n   * @param to address - Address to mint to`\\n   */\\n  function mint(address to) external returns (uint256) {\\n    require(hasAllRoles(msg.sender, CONTROLLER_ROLE), \\\"Web3Card:unauthorized\\\");\\n    require(_belongsTo[to] == 0, \\\"Web3Card:activated\\\");\\n    uint256 nextId;\\n    unchecked {\\n      nextId = _idCounter++;\\n      _belongsTo[to] = nextId;\\n      _mint(to, nextId);\\n    }\\n    return nextId;\\n  }\\n\\n  /**\\n   * @notice Burns a token\\n   * @param tokenId uint256 - Token ID to burn\\n   */\\n  function burn(uint256 tokenId) external {\\n    require(hasAllRoles(msg.sender, CONTROLLER_ROLE), \\\"Web3Card:unauthorized\\\");\\n    address owner = ownerOf(tokenId);\\n    _belongsTo[owner] = 0;\\n    _burn(tokenId);\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) public virtual override {\\n    _belongsTo[from] = 0;\\n    _belongsTo[to] = tokenId;\\n    super.transferFrom(from, to, tokenId);\\n  }\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) public virtual override {\\n    _belongsTo[from] = 0;\\n    _belongsTo[to] = tokenId;\\n    super.safeTransferFrom(from, to, tokenId);\\n  }\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) public virtual override {\\n    _belongsTo[from] = 0;\\n    _belongsTo[to] = tokenId;\\n    super.safeTransferFrom(from, to, tokenId, data);\\n  }\\n\\n  /* ===================================================================================== */\\n  /* Internal Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function _tokenData(uint256 _tokenId)\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (bytes memory, bytes memory)\\n  {\\n    bytes memory imageBytes = CardStorage(_erc721Storage).getImageBytes(_tokenId);\\n    bytes memory traitsBytes = CardStorage(_erc721Storage).getTraitsBytes(_tokenId);\\n    return (imageBytes, traitsBytes);\\n  }\\n}\\n\",\"keccak256\":\"0x82d79f19eb4a9ef873673be918499f263b8ab49235266d3a3de45856f55ea2a6\",\"license\":\"MIT\"},\"contracts/CardActivator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Owned } from \\\"./Solbase/Owned.sol\\\";\\nimport { Card } from \\\"./Card.sol\\\";\\nimport { CardDesign } from \\\"./CardDesign.sol\\\";\\n\\ncontract CardActivator is Owned {\\n  address public erc721KInstance;\\n  address public erc721KDesignInstance;\\n\\n  uint256 private STYLE_UPGRADE_VALUE = 0.01 ether;\\n\\n  constructor(\\n    address admin,\\n    address _erc721KInstance,\\n    address _erc721KDesignInstance\\n  ) Owned(admin) {\\n    erc721KInstance = _erc721KInstance;\\n    erc721KDesignInstance = _erc721KDesignInstance;\\n  }\\n\\n  function activate(address to) external {\\n    Card(erc721KInstance).mint(to);\\n  }\\n\\n  function activateWithStyle(\\n    address to,\\n    uint8 color,\\n    uint8 emoji\\n  ) external payable {\\n    if (color + emoji >= 1)\\n      require(msg.value >= STYLE_UPGRADE_VALUE, \\\"Web3CardActivator:insufficient-eth\\\");\\n    uint256 tokenId_ = Card(erc721KInstance).mint(to);\\n    CardDesign(erc721KDesignInstance).setDuringMint(tokenId_, color, emoji);\\n  }\\n\\n  function release(uint256 value) external onlyOwner {\\n    (bool _success, ) = msg.sender.call{ value: value }(\\\"\\\");\\n    require(_success, \\\"Web3CardActivator:eth-release-failed\\\");\\n  }\\n\\n  function setStyleUpgradeCost(uint256 value) external onlyOwner {\\n    STYLE_UPGRADE_VALUE = value;\\n  }\\n}\\n\",\"keccak256\":\"0x85eb2645eb6a5a97769fd5f8b694f414aceb10c62c8c5ce0ff6cd90e00f544a8\",\"license\":\"MIT\"},\"contracts/CardDesign.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC721 } from \\\"./Solbase/ERC721.sol\\\";\\nimport { OwnedThreeStep } from \\\"./Solbase/OwnedThreeStep.sol\\\";\\n\\ncontract CardDesign is OwnedThreeStep {\\n  address public erc721KActivatorInstance;\\n\\n  uint256 private STYLE_UPGRADE_VALUE = 0.01 ether;\\n\\n  mapping(uint256 => uint8) private _color;\\n  mapping(uint256 => uint8) private _emoji;\\n\\n  mapping(uint8 => bytes) private _colorMap;\\n  mapping(uint8 => string) private _emojiMap;\\n\\n  mapping(address => bool) private _supporter;\\n\\n  /* ===================================================================================== */\\n  /* Constructor & Modifiers                                                               */\\n  /* ===================================================================================== */\\n\\n  constructor(address _owner) OwnedThreeStep(_owner) {\\n    _colorMap[0] = hex\\\"6236C5\\\"; // Purple\\n    _colorMap[1] = hex\\\"224396\\\"; // Blue\\n    _colorMap[2] = hex\\\"922B2B\\\"; // Red\\n    _colorMap[3] = hex\\\"498933\\\"; // Green\\n    _colorMap[4] = hex\\\"313131\\\"; // Black\\n\\n    _emojiMap[0] = unicode\\\"\\ud83c\\udfe6\\\";\\n    _emojiMap[1] = unicode\\\"\\ud83e\\udd9c\\\";\\n    _emojiMap[2] = unicode\\\"\\ud83e\\udd8a\\\";\\n    _emojiMap[3] = unicode\\\"\\ud83e\\udd84\\\";\\n    _emojiMap[4] = unicode\\\"\\ud83d\\udc19\\\";\\n    _emojiMap[5] = unicode\\\"\\ud83d\\udc35\\\";\\n    _emojiMap[6] = unicode\\\"\\ud83d\\udc33\\\";\\n    _emojiMap[7] = unicode\\\"\\ud83d\\udc1d\\\";\\n    _emojiMap[8] = unicode\\\"\\ud83d\\udc3a\\\";\\n    _emojiMap[9] = unicode\\\"\\ud83d\\udc51\\\";\\n    _emojiMap[10] = unicode\\\"\\ud83d\\ude80\\\";\\n    _emojiMap[11] = unicode\\\"\\ud83c\\udf08\\\";\\n    _emojiMap[12] = unicode\\\"\\ud83e\\udeb6\\\";\\n    _emojiMap[13] = unicode\\\"\\ud83e\\uddf8\\\";\\n    _emojiMap[14] = unicode\\\"\\ud83c\\udf81\\\";\\n    _emojiMap[15] = unicode\\\"\\ud83d\\udc8c\\\";\\n    _emojiMap[16] = unicode\\\"\\ud83c\\udf80\\\";\\n    _emojiMap[17] = unicode\\\"\\ud83d\\udd2e\\\";\\n    _emojiMap[18] = unicode\\\"\\ud83d\\udc8e\\\";\\n    _emojiMap[19] = unicode\\\"\\ud83e\\ude85\\\";\\n    _emojiMap[20] = unicode\\\"\\ud83c\\udfd7\\\";\\n    _emojiMap[21] = unicode\\\"\\ud83e\\uddf0\\\";\\n    _emojiMap[22] = unicode\\\"\\ud83e\\uddf2\\\";\\n    _emojiMap[23] = unicode\\\"\\ud83e\\uddea\\\";\\n    _emojiMap[24] = unicode\\\"\\ud83d\\udee1\\ufe0f\\\";\\n    _emojiMap[25] = unicode\\\"\\ud83e\\uddec\\\";\\n    _emojiMap[26] = unicode\\\"\\ud83e\\udded\\\";\\n    _emojiMap[27] = unicode\\\"\\ud83e\\uddee\\\";\\n    _emojiMap[28] = unicode\\\"\\u2694\\ufe0f\\\";\\n    _emojiMap[29] = unicode\\\"\\ud83e\\uddf0\\\";\\n    _emojiMap[30] = unicode\\\"\\ud83e\\uddf1\\\";\\n    _emojiMap[31] = unicode\\\"\\u26d3\\ufe0f\\\";\\n    _emojiMap[32] = unicode\\\"\\ud83c\\udfc8\\\";\\n    _emojiMap[33] = unicode\\\"\\ud83c\\udfc0\\\";\\n    _emojiMap[34] = unicode\\\"\\u26bd\\ufe0f\\\";\\n    _emojiMap[35] = unicode\\\"\\ud83c\\udfd0\\\";\\n    _emojiMap[36] = unicode\\\"\\ud83c\\udfd3\\\";\\n    _emojiMap[37] = unicode\\\"\\ud83c\\udfbe\\\";\\n    _emojiMap[38] = unicode\\\"\\ud83c\\udfb2\\\";\\n    _emojiMap[39] = unicode\\\"\\ud83c\\udfc9\\\";\\n    _emojiMap[40] = unicode\\\"\\ud83c\\udfbd\\\";\\n    _emojiMap[41] = unicode\\\"\\ud83c\\udfc6\\\";\\n    _emojiMap[42] = unicode\\\"\\ud83c\\udfaf\\\";\\n  }\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function getEmoji(uint256 tokenId) external view returns (string memory) {\\n    return _emojiMap[_emoji[tokenId]];\\n  }\\n\\n  function getColor(uint256 tokenId) external view returns (bytes memory) {\\n    return _colorMap[_color[tokenId]];\\n  }\\n\\n  function getEmojiFromMap(uint8 emojiId) external view returns (string memory) {\\n    return _emojiMap[emojiId];\\n  }\\n\\n  function getColorFromMap(uint8 colorId) external view returns (bytes memory) {\\n    return _colorMap[colorId];\\n  }\\n\\n  function setDuringMint(\\n    uint256 tokenId,\\n    uint8 color,\\n    uint8 emoji\\n  ) external {\\n    require(msg.sender == erc721KActivatorInstance, \\\"Web3CardDesign:not-authorized\\\");\\n    _color[tokenId] = color;\\n    _emoji[tokenId] = emoji;\\n  }\\n\\n  function setEmoji(uint256 tokenId, uint8 emoji) external payable {\\n    require(msg.value >= STYLE_UPGRADE_VALUE, \\\"Web3CardDesign:insufficient-eth\\\");\\n    require(\\n      msg.sender == ERC721(erc721KActivatorInstance).ownerOf(tokenId),\\n      \\\"Web3CardDesign:not-owner\\\"\\n    );\\n    _emoji[tokenId] = emoji;\\n    _call(msg.value);\\n  }\\n\\n  function setColor(uint256 tokenId, uint8 color) external payable {\\n    require(msg.value >= STYLE_UPGRADE_VALUE, \\\"Web3CardDesign:insufficient-eth\\\");\\n    require(\\n      msg.sender == ERC721(erc721KActivatorInstance).ownerOf(tokenId),\\n      \\\"Web3CardDesign:not-owner\\\"\\n    );\\n    _color[tokenId] = color;\\n    _call(msg.value);\\n  }\\n\\n  function setERC721KActivatorInstance(address _erc721KActivatorInstance) external onlyOwner {\\n    erc721KActivatorInstance = _erc721KActivatorInstance;\\n  }\\n\\n  function setStyleUpgradeCost(uint256 _styleUpgradeCost) external onlyOwner {\\n    STYLE_UPGRADE_VALUE = _styleUpgradeCost;\\n  }\\n\\n  function _call(uint256 value) internal {\\n    (bool _success, ) = erc721KActivatorInstance.call{ value: value }(\\\"\\\");\\n    require(_success, \\\"Web3CardDesign:call-failed\\\");\\n  }\\n}\\n\",\"keccak256\":\"0xf9a53f29eac90595e1223f5cb7770bdf98ff88815d32aa4112d61dfa201be33a\",\"license\":\"MIT\"},\"contracts/CardStorage.sol\":{\"content\":\"pragma solidity 0.8.15;\\n\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport { ERC721Storage } from \\\"./ERC721K/ERC721Storage.sol\\\";\\nimport { ERC721 } from \\\"./Solbase/ERC721.sol\\\";\\nimport { TwabLib } from \\\"./PoolTogether/twab/TwabLib.sol\\\";\\nimport { ERC20TWAB } from \\\"./PoolTogether/ERC20TWAB.sol\\\";\\nimport { CardDesign } from \\\"./CardDesign.sol\\\";\\n\\n/*\\n * @title CardStorage\\n * @author Kames Geraghty\\n * @description CardStorge provides storage and rendering instriutions for the Card contract.\\n */\\ncontract CardStorage is ERC721Storage {\\n  address public assetUnderlying;\\n\\n  /// Smart Contact Instance(s)\\n  address public erc20TWABInstance;\\n  address public erc721KInstance;\\n  address public erc721KDesignInstance;\\n\\n  bytes private DEFAULT_COLOR = hex\\\"6236C5\\\";\\n\\n  mapping(uint256 => string) private _name;\\n  mapping(uint256 => string) private _emojiMap;\\n\\n  constructor(\\n    address _svgRender_,\\n    address _traitsFetch_,\\n    ContractURI memory _contractURI_,\\n    address _erc20TWABInstance,\\n    address _erc721KDesignInstance,\\n    address _assetUnderlying\\n  ) ERC721Storage(_svgRender_, _traitsFetch_, _contractURI_) {\\n    erc20TWABInstance = _erc20TWABInstance;\\n    erc721KDesignInstance = _erc721KDesignInstance;\\n    assetUnderlying = _assetUnderlying;\\n  }\\n\\n  struct RenderMetadata {\\n    uint256 balance;\\n    uint256 chance;\\n    uint256 avgBalance2Weeks;\\n    uint256 avgBalance8Weeks;\\n    uint256 avgBalance26Weeks;\\n    uint256 avgBalance52Weeks;\\n    string emoji;\\n    bytes color;\\n  }\\n\\n  /// =====================================================================================\\n  /// Override Functions\\n  /// =====================================================================================\\n  function _parseName(uint256 _tokenId) internal view override returns (string memory) {\\n    return string.concat(\\\"Web3 Savings Card #\\\", Strings.toString(_tokenId));\\n  }\\n\\n  function _parseDescription(uint256 _tokenId) internal view override returns (string memory) {\\n    return \\\"Member of the Web3 Savings Network\\\";\\n  }\\n\\n  /// =====================================================================================\\n  /// External Functions\\n  /// =====================================================================================\\n\\n  /// ===================================\\n  /// Getters\\n  /// ===================================\\n\\n  function getImageBytes(uint256 tokenId) external view returns (bytes memory) {\\n    address account = ERC721(erc721KInstance).ownerOf(tokenId);\\n    return _generateBytesData(tokenId, account);\\n  }\\n\\n  function getTraitsBytes(uint256 tokenId) external view returns (bytes memory) {\\n    address account = ERC721(erc721KInstance).ownerOf(tokenId);\\n    return _generateBytesData(tokenId, account);\\n  }\\n\\n  function getPreview(address account) external view returns (bytes memory imageData) {\\n    return _generateBytesData(0, account);\\n  }\\n\\n  function _generateBytesData(uint256 _tokenId, address account)\\n    internal\\n    view\\n    returns (bytes memory bytesData)\\n  {\\n    uint256 balance;\\n    TwabLib.AccountDetails memory accountDetails;\\n    RenderMetadata memory renderMetadata;\\n\\n    renderMetadata.emoji = CardDesign(erc721KDesignInstance).getEmoji(_tokenId);\\n    renderMetadata.color = CardDesign(erc721KDesignInstance).getColor(_tokenId);\\n\\n    if (bytes(renderMetadata.emoji).length == 0) {\\n      renderMetadata.emoji = unicode\\\"\\ud83d\\udcb3\\\";\\n    }\\n\\n    if (renderMetadata.color.length == 0) {\\n      renderMetadata.color = DEFAULT_COLOR;\\n    }\\n\\n    if (erc20TWABInstance != address(0)) {\\n      balance = ERC20TWAB(erc20TWABInstance).balanceOf(account);\\n      accountDetails = ERC20TWAB(erc20TWABInstance).getAccountDetails(account);\\n      /// Average Balances\\n      uint64 end = uint64(block.timestamp);\\n      renderMetadata.avgBalance2Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 2 weeks),\\n        end\\n      );\\n      renderMetadata.avgBalance8Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 8 weeks),\\n        end\\n      );\\n      renderMetadata.avgBalance26Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 26 weeks),\\n        end\\n      );\\n      renderMetadata.avgBalance52Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 52 weeks),\\n        end\\n      );\\n    }\\n\\n    bytesData = bytes(\\n      abi.encode(\\n        account,\\n        assetUnderlying, // Underlying Asset\\n        balance, /// Balance\\n        accountDetails.balance, /// Balance + Delegations\\n        renderMetadata.avgBalance2Weeks,\\n        renderMetadata.avgBalance8Weeks,\\n        renderMetadata.avgBalance26Weeks,\\n        renderMetadata.avgBalance52Weeks,\\n        renderMetadata.emoji,\\n        renderMetadata.color\\n      )\\n    );\\n  }\\n\\n  function getPreviewWithStyle(\\n    address account,\\n    uint8 color,\\n    uint8 emoji\\n  ) external view returns (bytes memory bytesData) {\\n    uint256 balance;\\n    TwabLib.AccountDetails memory accountDetails;\\n    RenderMetadata memory renderMetadata;\\n\\n    renderMetadata.color = CardDesign(erc721KDesignInstance).getColorFromMap(color);\\n    renderMetadata.emoji = CardDesign(erc721KDesignInstance).getEmojiFromMap(emoji);\\n\\n    if (bytes(renderMetadata.emoji).length == 0) {\\n      renderMetadata.emoji = unicode\\\"\\ud83d\\udcb3\\\";\\n    }\\n\\n    if (renderMetadata.color.length == 0) {\\n      renderMetadata.color = DEFAULT_COLOR;\\n    }\\n\\n    if (erc20TWABInstance != address(0)) {\\n      balance = ERC20TWAB(erc20TWABInstance).balanceOf(account);\\n      accountDetails = ERC20TWAB(erc20TWABInstance).getAccountDetails(account);\\n      /// Average Balances\\n      uint64 end = uint64(block.timestamp);\\n      renderMetadata.avgBalance2Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 2 weeks),\\n        end\\n      );\\n      renderMetadata.avgBalance8Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 8 weeks),\\n        end\\n      );\\n      renderMetadata.avgBalance26Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 26 weeks),\\n        end\\n      );\\n      renderMetadata.avgBalance52Weeks = ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(\\n        account,\\n        uint64(block.timestamp - 52 weeks),\\n        end\\n      );\\n    }\\n\\n    bytesData = bytes(\\n      abi.encode(\\n        account,\\n        assetUnderlying, // Underlying Asset\\n        balance, /// Balance\\n        accountDetails.balance, /// Balance + Delegations\\n        renderMetadata.avgBalance2Weeks,\\n        renderMetadata.avgBalance8Weeks,\\n        renderMetadata.avgBalance26Weeks,\\n        renderMetadata.avgBalance52Weeks,\\n        renderMetadata.emoji,\\n        renderMetadata.color\\n      )\\n    );\\n  }\\n\\n  /// ===================================\\n  /// Setters\\n  /// ===================================\\n\\n  function setERC721KInstance(address _erc721KInstance) external onlyOwner {\\n    erc721KInstance = _erc721KInstance;\\n  }\\n\\n  function setERC721KDesignInstance(address _erc721KDesignInstance) external onlyOwner {\\n    erc721KDesignInstance = _erc721KDesignInstance;\\n  }\\n\\n  function setERC20TWABInstance(address _erc20TWABInstance) external onlyOwner {\\n    erc20TWABInstance = _erc20TWABInstance;\\n  }\\n\\n  /// =====================================================================================\\n  /// Internal Functions\\n  /// =====================================================================================\\n\\n  function _getAverageBalance(\\n    address _account,\\n    uint64 _start,\\n    uint64 _end\\n  ) internal view returns (uint256) {\\n    return ERC20TWAB(erc20TWABInstance).getAverageBalanceBetween(_account, _start, _end);\\n  }\\n}\\n\",\"keccak256\":\"0x17e9e22d811766efcfa2c18ff8ea2e63fc03935f169b76a5a6929ab14ac7ea0c\"},\"contracts/ERC721K/ERC721K.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC721 } from \\\"../Solbase/ERC721.sol\\\";\\nimport { OwnedRoles } from \\\"../Solbase/OwnedRoles.sol\\\";\\nimport { ERC721Storage } from \\\"./ERC721Storage.sol\\\";\\n\\n/**\\n * @title ERC721K\\n * @author Kames Geraghty\\n */\\nabstract contract ERC721K is ERC721, OwnedRoles {\\n  /// @notice ID counter for ERC721 tokens\\n  uint256 internal _idCounter;\\n\\n  /// @notice ENSReverseRecords instance\\n  address internal _erc721Storage;\\n\\n  event ERC721StorageUpdated(address erc721Storage);\\n\\n  /**\\n   * @notice ERC721K Construction\\n   * @param name_ string - Name of ERC721 token\\n   * @param symbol_ string - Symbol of ERC721 token\\n   * @param _erc721Storage_ address - Metadata instance\\n   */\\n  constructor(\\n    string memory name_,\\n    string memory symbol_,\\n    address _erc721Storage_\\n  ) ERC721(name_, symbol_) {\\n    _erc721Storage = _erc721Storage_;\\n    _initializeOwner(msg.sender);\\n  }\\n\\n  /* ===================================================================================== */\\n  /* EIP Functions                                                                     */\\n  /* ===================================================================================== */\\n  function supportsInterface(bytes4 interfaceId)\\n    public\\n    view\\n    virtual\\n    override(ERC721)\\n    returns (bool)\\n  {\\n    return super.supportsInterface(interfaceId);\\n  }\\n\\n  /* ===================================================================================== */\\n  /* Virtual Functions                                                                     */\\n  /* ===================================================================================== */\\n  function _tokenData(uint256 tokenId)\\n    internal\\n    view\\n    virtual\\n    returns (bytes memory imageBytes, bytes memory traitsBytes);\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function contractURI() external view returns (string memory) {\\n    return ERC721Storage(_erc721Storage).constructContractURI();\\n  }\\n\\n  function totalSupply() external view returns (uint256) {\\n    return _idCounter;\\n  }\\n\\n  function getERC721Storage() external view returns (address) {\\n    return _erc721Storage;\\n  }\\n\\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n    (bytes memory imageBytes, bytes memory traitsBytes) = _tokenData(tokenId);\\n    return ERC721Storage(_erc721Storage).constructTokenURI(tokenId, imageBytes, traitsBytes);\\n  }\\n\\n  /* ====================================== */\\n  /* Writes\\n  /* ====================================== */\\n\\n  function setStorage(address erc721Storage) external onlyOwner {\\n    _erc721Storage = erc721Storage;\\n    emit ERC721StorageUpdated(erc721Storage);\\n  }\\n}\\n\",\"keccak256\":\"0x586725e3cbc1563cf1e78ed0c90da102505d2b0a0b5a2b8ff899405e28e4e5bb\",\"license\":\"MIT\"},\"contracts/ERC721K/ERC721Storage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\nimport { Base64 } from \\\"../Solbase/Base64.sol\\\";\\nimport { OwnedRoles } from \\\"../Solbase/OwnedRoles.sol\\\";\\nimport { IERC721KImage } from \\\"./interfaces/IERC721KImage.sol\\\";\\nimport { IERC721KTraits } from \\\"./interfaces/IERC721KTraits.sol\\\";\\n\\n/**\\n * @title ERC721Storage\\n * @author Kames Geraghty\\n */\\nabstract contract ERC721Storage is OwnedRoles {\\n  address internal svgRenderInstance;\\n  address internal traitsFetchInstance;\\n  ContractURI internal _contractURI;\\n\\n  struct ContractURI {\\n    string name;\\n    string description;\\n    string image;\\n    string externalLink;\\n    string sellerFeeBasisPoints;\\n    string feeRecipient;\\n  }\\n\\n  event SvgRenderUpdated(address svgRender);\\n\\n  event TraitsFetchUpdated(address traitsFetch);\\n\\n  event ContractURIUpdated(ContractURI contractURI);\\n\\n  constructor(\\n    address svgRender_Instance,\\n    address traitsFetchInstance_,\\n    ContractURI memory _contractURI_\\n  ) OwnedRoles() {\\n    svgRenderInstance = svgRender_Instance;\\n    traitsFetchInstance = traitsFetchInstance_;\\n    _contractURI = _contractURI_;\\n    _initializeOwner(msg.sender);\\n  }\\n\\n  /* ===================================================================================== */\\n  /* Virtual Functions                                                                     */\\n  /* ===================================================================================== */\\n\\n  function _parseName(uint256 _tokenId) internal view virtual returns (string memory);\\n\\n  function _parseDescription(uint256 _tokenId) internal view virtual returns (string memory);\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n  function getERC721KRender() external view returns (address) {\\n    return svgRenderInstance;\\n  }\\n\\n  function getERC72KTraits() external view returns (address) {\\n    return traitsFetchInstance;\\n  }\\n\\n  function getContractDescription() external view returns (ContractURI memory) {\\n    return _contractURI;\\n  }\\n\\n  function render(bytes memory input) external view returns (string memory) {\\n    return IERC721KImage(svgRenderInstance).render(input);\\n  }\\n\\n  function constructTokenURI(\\n    uint256 tokenId,\\n    bytes memory input0,\\n    bytes memory input1\\n  ) external view virtual returns (string memory uri) {\\n    string memory image_ = IERC721KImage(svgRenderInstance).render(input0);\\n    string memory traits_ = IERC721KTraits(traitsFetchInstance).fetch(input1);\\n    return\\n      string(\\n        abi.encodePacked(\\n          \\\"data:application/json;base64,\\\",\\n          Base64.encode(\\n            bytes(\\n              string.concat(\\n                '{\\\"name\\\":',\\n                '\\\"',\\n                _parseName(tokenId),\\n                '\\\",',\\n                '\\\"description\\\":',\\n                '\\\"',\\n                _parseDescription(tokenId),\\n                '\\\",',\\n                '\\\"image\\\":',\\n                '\\\"',\\n                image_,\\n                '\\\",',\\n                '\\\"attributes\\\": [',\\n                traits_,\\n                \\\"]\\\",\\n                \\\"}\\\"\\n              )\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  function constructContractURI() external view virtual returns (string memory uri) {\\n    return\\n      string(\\n        abi.encodePacked(\\n          \\\"data:application/json;base64,\\\",\\n          Base64.encode(\\n            bytes(\\n              string.concat(\\n                '{\\\"name\\\":',\\n                '\\\"',\\n                _contractURI.name,\\n                '\\\",',\\n                '\\\"description\\\":',\\n                '\\\"',\\n                _contractURI.description,\\n                '\\\",',\\n                '\\\"image\\\":',\\n                '\\\"',\\n                _contractURI.image,\\n                '\\\",',\\n                '\\\"externalLink\\\":',\\n                '\\\"',\\n                _contractURI.externalLink,\\n                '\\\",',\\n                '\\\"sellerFeeBasisPoints\\\":',\\n                '\\\"',\\n                _contractURI.sellerFeeBasisPoints,\\n                '\\\",',\\n                '\\\"feeRecipient\\\":',\\n                '\\\"',\\n                _contractURI.feeRecipient,\\n                '\\\"',\\n                \\\"}\\\"\\n              )\\n            )\\n          )\\n        )\\n      );\\n  }\\n\\n  function setSvgRender(address svgRender) external onlyOwner {\\n    svgRenderInstance = svgRender;\\n    emit SvgRenderUpdated(svgRender);\\n  }\\n\\n  function setTraitsFetch(address traitsFetch) external onlyOwner {\\n    traitsFetchInstance = traitsFetch;\\n    emit TraitsFetchUpdated(traitsFetch);\\n  }\\n\\n  function setContractURI(ContractURI memory contractURI) external onlyOwner {\\n    _contractURI = contractURI;\\n    emit ContractURIUpdated(contractURI);\\n  }\\n}\\n\",\"keccak256\":\"0x01246b681f1c7300b21155882518bb628507ba777603715fef427a1d149ffc7c\",\"license\":\"GPL-3.0\"},\"contracts/ERC721K/interfaces/IERC721KImage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\ninterface IERC721KImage {\\n  function render(bytes memory input) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x8474249915bfc50221f4431b8853338ae27e8847ac3ef563dda437dd809a8846\",\"license\":\"MIT\"},\"contracts/ERC721K/interfaces/IERC721KTraits.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\ninterface IERC721KTraits {\\n  enum DisplayType {\\n    Base,\\n    Generic,\\n    BoostNumber,\\n    BoostPercent,\\n    Number,\\n    Date\\n  }\\n\\n  function fetch(bytes memory input) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xeea24a181f0175f89ed357503946fbbb39c92a1b2b4764268d4613a773f3c9ea\",\"license\":\"MIT\"},\"contracts/ERC721K/interfaces/ISVGRender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\ninterface ISVGRender {\\n  function render(bytes memory input) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x40b1890b472a84f0867a826065039eb787f1f3c4f1a79a71b877752c70152967\",\"license\":\"MIT\"},\"contracts/PoolTogether/ERC20TWAB.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC20 } from \\\"../Solbase/ERC20.sol\\\";\\nimport { ERC20Permit } from \\\"../Solbase/ERC20Permit.sol\\\";\\nimport { ObservationLib } from \\\"./twab/ObservationLib.sol\\\";\\nimport { TwabLib } from \\\"./twab/TwabLib.sol\\\";\\nimport { ExtendedSafeCastLib } from \\\"./twab/ExtendedSafeCastLib.sol\\\";\\n\\n/**\\n * @title ERC20TWAB\\n * @author Kames Geraghty\\n * @notice ERC20TWAB is an experiment. Implementing time-weighted average balances on more ERC20 tokens.\\n           Credit: PoolTogether Inc (Brendan Asselstine)\\n */\\ncontract ERC20TWAB is ERC20 {\\n  // using SafeERC20 for IERC20;\\n  using ExtendedSafeCastLib for uint256;\\n\\n  uint256 private distribution = 10000e18;\\n\\n  bytes32 private immutable _DELEGATE_TYPEHASH =\\n    keccak256(\\\"Delegate(address user,address delegate,uint256 nonce,uint256 deadline)\\\");\\n\\n  /// @notice Record of token holders TWABs for each account.\\n  mapping(address => TwabLib.Account) internal userTwabs;\\n\\n  /// @notice Record of tickets total supply and ring buff parameters used for observation.\\n  TwabLib.Account internal totalSupplyTwab;\\n\\n  /// @notice Mapping of delegates.  Each address can delegate their ticket power to another.\\n  mapping(address => address) internal delegates;\\n\\n  /**\\n   * @notice Emitted when TWAB balance has been delegated to another user.\\n   * @param delegator Address of the delegator.\\n   * @param delegate Address of the delegate.\\n   */\\n  event Delegated(address indexed delegator, address indexed delegate);\\n\\n  /**\\n   * @notice Emitted when a new TWAB has been recorded.\\n   * @param delegate The recipient of the ticket power (may be the same as the user).\\n   * @param newTwab Updated TWAB of a ticket holder after a successful TWAB recording.\\n   */\\n  event NewUserTwab(address indexed delegate, ObservationLib.Observation newTwab);\\n\\n  /**\\n   * @notice Emitted when a new total supply TWAB has been recorded.\\n   * @param newTotalSupplyTwab Updated TWAB of tickets total supply after a successful total supply TWAB recording.\\n   */\\n  event NewTotalSupplyTwab(ObservationLib.Observation newTotalSupplyTwab);\\n\\n  constructor(string memory name, string memory symbol)\\n    ERC20(name, symbol, 18)\\n  {}\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function getAccountDetails(address _user) external view returns (TwabLib.AccountDetails memory) {\\n    return userTwabs[_user].details;\\n  }\\n\\n  function getTwab(address _user, uint16 _index)\\n    external\\n    view\\n    returns (ObservationLib.Observation memory)\\n  {\\n    return userTwabs[_user].twabs[_index];\\n  }\\n\\n  function getBalanceAt(address _user, uint64 _target) external view returns (uint256) {\\n    TwabLib.Account storage account = userTwabs[_user];\\n\\n    return\\n      TwabLib.getBalanceAt(\\n        account.twabs,\\n        account.details,\\n        uint32(_target),\\n        uint32(block.timestamp)\\n      );\\n  }\\n\\n  function getAverageBalancesBetween(\\n    address _user,\\n    uint64[] calldata _startTimes,\\n    uint64[] calldata _endTimes\\n  ) external view returns (uint256[] memory) {\\n    return _getAverageBalancesBetween(userTwabs[_user], _startTimes, _endTimes);\\n  }\\n\\n  function getAverageTotalSuppliesBetween(\\n    uint64[] calldata _startTimes,\\n    uint64[] calldata _endTimes\\n  ) external view returns (uint256[] memory) {\\n    return _getAverageBalancesBetween(totalSupplyTwab, _startTimes, _endTimes);\\n  }\\n\\n  function getAverageBalanceBetween(\\n    address _user,\\n    uint64 _startTime,\\n    uint64 _endTime\\n  ) external view returns (uint256) {\\n    TwabLib.Account storage account = userTwabs[_user];\\n\\n    return\\n      TwabLib.getAverageBalanceBetween(\\n        account.twabs,\\n        account.details,\\n        uint32(_startTime),\\n        uint32(_endTime),\\n        uint32(block.timestamp)\\n      );\\n  }\\n\\n  function getBalancesAt(address _user, uint64[] calldata _targets)\\n    external\\n    view\\n    returns (uint256[] memory)\\n  {\\n    uint256 length = _targets.length;\\n    uint256[] memory _balances = new uint256[](length);\\n\\n    TwabLib.Account storage twabContext = userTwabs[_user];\\n    TwabLib.AccountDetails memory details = twabContext.details;\\n\\n    for (uint256 i = 0; i < length; i++) {\\n      _balances[i] = TwabLib.getBalanceAt(\\n        twabContext.twabs,\\n        details,\\n        uint32(_targets[i]),\\n        uint32(block.timestamp)\\n      );\\n    }\\n\\n    return _balances;\\n  }\\n\\n  function getTotalSupplyAt(uint64 _target) external view returns (uint256) {\\n    return\\n      TwabLib.getBalanceAt(\\n        totalSupplyTwab.twabs,\\n        totalSupplyTwab.details,\\n        uint32(_target),\\n        uint32(block.timestamp)\\n      );\\n  }\\n\\n  function getTotalSuppliesAt(uint64[] calldata _targets) external view returns (uint256[] memory) {\\n    uint256 length = _targets.length;\\n    uint256[] memory totalSupplies = new uint256[](length);\\n\\n    TwabLib.AccountDetails memory details = totalSupplyTwab.details;\\n\\n    for (uint256 i = 0; i < length; i++) {\\n      totalSupplies[i] = TwabLib.getBalanceAt(\\n        totalSupplyTwab.twabs,\\n        details,\\n        uint32(_targets[i]),\\n        uint32(block.timestamp)\\n      );\\n    }\\n\\n    return totalSupplies;\\n  }\\n\\n  function delegateOf(address _user) external view returns (address) {\\n    return delegates[_user];\\n  }\\n\\n\\n  function delegate(address _to) external virtual {\\n    _delegate(msg.sender, _to);\\n  }\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  /// @notice Delegates a users chance to another\\n  /// @param _user The user whose balance should be delegated\\n  /// @param _to The delegate\\n  function _delegate(address _user, address _to) internal {\\n    uint256 balance = 0;\\n    address currentDelegate = delegates[_user];\\n\\n    if (currentDelegate == _to) {\\n      return;\\n    }\\n\\n    delegates[_user] = _to;\\n\\n    _transferTwab(currentDelegate, _to, balance);\\n\\n    emit Delegated(_user, _to);\\n  }\\n\\n  /**\\n   * @notice Retrieves the average balances held by a user for a given time frame.\\n   * @param _account The user whose balance is checked.\\n   * @param _startTimes The start time of the time frame.\\n   * @param _endTimes The end time of the time frame.\\n   * @return The average balance that the user held during the time frame.\\n   */\\n  function _getAverageBalancesBetween(\\n    TwabLib.Account storage _account,\\n    uint64[] calldata _startTimes,\\n    uint64[] calldata _endTimes\\n  ) internal view returns (uint256[] memory) {\\n    uint256 startTimesLength = _startTimes.length;\\n    require(startTimesLength == _endTimes.length, \\\"Ticket/start-end-times-length-match\\\");\\n\\n    TwabLib.AccountDetails memory accountDetails = _account.details;\\n\\n    uint256[] memory averageBalances = new uint256[](startTimesLength);\\n    uint32 currentTimestamp = uint32(block.timestamp);\\n\\n    for (uint256 i = 0; i < startTimesLength; i++) {\\n      averageBalances[i] = TwabLib.getAverageBalanceBetween(\\n        _account.twabs,\\n        accountDetails,\\n        uint32(_startTimes[i]),\\n        uint32(_endTimes[i]),\\n        currentTimestamp\\n      );\\n    }\\n\\n    return averageBalances;\\n  }\\n\\n  /// @notice Transfers the given TWAB balance from one user to another\\n  /// @param _from The user to transfer the balance from.  May be zero in the event of a mint.\\n  /// @param _to The user to transfer the balance to.  May be zero in the event of a burn.\\n  /// @param _amount The balance that is being transferred.\\n  function _transferTwab(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) internal {\\n    // If we are transferring tokens from a delegated account to an undelegated account\\n    if (_from != address(0)) {\\n      _decreaseUserTwab(_from, _amount);\\n\\n      if (_to == address(0)) {\\n        _decreaseTotalSupplyTwab(_amount);\\n      }\\n    }\\n\\n    // If we are transferring tokens from an undelegated account to a delegated account\\n    if (_to != address(0)) {\\n      _increaseUserTwab(_to, _amount);\\n\\n      if (_from == address(0)) {\\n        _increaseTotalSupplyTwab(_amount);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Increase `_to` TWAB balance.\\n   * @param _to Address of the delegate.\\n   * @param _amount Amount of tokens to be added to `_to` TWAB balance.\\n   */\\n  function _increaseUserTwab(address _to, uint256 _amount) internal {\\n    if (_amount == 0) {\\n      return;\\n    }\\n\\n    TwabLib.Account storage _account = userTwabs[_to];\\n\\n    (\\n      TwabLib.AccountDetails memory accountDetails,\\n      ObservationLib.Observation memory twab,\\n      bool isNew\\n    ) = TwabLib.increaseBalance(_account, _amount.toUint208(), uint32(block.timestamp));\\n\\n    _account.details = accountDetails;\\n\\n    if (isNew) {\\n      emit NewUserTwab(_to, twab);\\n    }\\n  }\\n\\n  /**\\n   * @notice Decrease `_to` TWAB balance.\\n   * @param _to Address of the delegate.\\n   * @param _amount Amount of tokens to be added to `_to` TWAB balance.\\n   */\\n  function _decreaseUserTwab(address _to, uint256 _amount) internal {\\n    if (_amount == 0) {\\n      return;\\n    }\\n\\n    TwabLib.Account storage _account = userTwabs[_to];\\n\\n    (\\n      TwabLib.AccountDetails memory accountDetails,\\n      ObservationLib.Observation memory twab,\\n      bool isNew\\n    ) = TwabLib.decreaseBalance(\\n        _account,\\n        _amount.toUint208(),\\n        \\\"Ticket/twab-burn-lt-balance\\\",\\n        uint32(block.timestamp)\\n      );\\n\\n    _account.details = accountDetails;\\n\\n    if (isNew) {\\n      emit NewUserTwab(_to, twab);\\n    }\\n  }\\n\\n  /// @notice Decreases the total supply twab.  Should be called anytime a balance moves from delegated to undelegated\\n  /// @param _amount The amount to decrease the total by\\n  function _decreaseTotalSupplyTwab(uint256 _amount) internal {\\n    if (_amount == 0) {\\n      return;\\n    }\\n\\n    (\\n      TwabLib.AccountDetails memory accountDetails,\\n      ObservationLib.Observation memory tsTwab,\\n      bool tsIsNew\\n    ) = TwabLib.decreaseBalance(\\n        totalSupplyTwab,\\n        _amount.toUint208(),\\n        \\\"Ticket/burn-amount-exceeds-total-supply-twab\\\",\\n        uint32(block.timestamp)\\n      );\\n\\n    totalSupplyTwab.details = accountDetails;\\n\\n    if (tsIsNew) {\\n      emit NewTotalSupplyTwab(tsTwab);\\n    }\\n  }\\n\\n  /// @notice Increases the total supply twab.  Should be called anytime a balance moves from undelegated to delegated\\n  /// @param _amount The amount to increase the total by\\n  function _increaseTotalSupplyTwab(uint256 _amount) internal {\\n    if (_amount == 0) {\\n      return;\\n    }\\n\\n    (\\n      TwabLib.AccountDetails memory accountDetails,\\n      ObservationLib.Observation memory _totalSupply,\\n      bool tsIsNew\\n    ) = TwabLib.increaseBalance(totalSupplyTwab, _amount.toUint208(), uint32(block.timestamp));\\n\\n    totalSupplyTwab.details = accountDetails;\\n\\n    if (tsIsNew) {\\n      emit NewTotalSupplyTwab(_totalSupply);\\n    }\\n  }\\n\\n  // @inheritdoc ERC20\\n  function _beforeTokenTransfer(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) internal  {\\n    if (_from == _to) {\\n      return;\\n    }\\n\\n    address _fromDelegate;\\n    if (_from != address(0)) {\\n      _fromDelegate = delegates[_from];\\n    }\\n\\n    address _toDelegate;\\n    if (_to != address(0)) {\\n      _toDelegate = delegates[_to];\\n    }\\n\\n    _transferTwab(_fromDelegate, _toDelegate, _amount);\\n  }\\n}\\n\",\"keccak256\":\"0x46e25c8cfc046017ff6060a0579f6bdbe9c67260a499e382526cef2ac1349e5f\",\"license\":\"MIT\"},\"contracts/PoolTogether/twab/ExtendedSafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.15;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary ExtendedSafeCastLib {\\n  /**\\n   * @dev Returns the downcasted uint104 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint104).\\n   *\\n   * Counterpart to Solidity's `uint104` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 104 bits\\n   */\\n  function toUint104(uint256 _value) internal pure returns (uint104) {\\n    require(_value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    return uint104(_value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint208 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint208).\\n   *\\n   * Counterpart to Solidity's `uint208` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 208 bits\\n   */\\n  function toUint208(uint256 _value) internal pure returns (uint208) {\\n    require(_value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    return uint208(_value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint224 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint224).\\n   *\\n   * Counterpart to Solidity's `uint224` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   */\\n  function toUint224(uint256 _value) internal pure returns (uint224) {\\n    require(_value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    return uint224(_value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint192 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint192).\\n   *\\n   * Counterpart to Solidity's `uint192` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   */\\n  function toUint192(uint256 value) internal pure returns (uint192) {\\n    require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    return uint192(value);\\n  }\\n}\\n\",\"keccak256\":\"0x5b06b3c63b7d32055d3d04d3eaa7152a2d7439f6069b5d99cce3cdcfe43f62ef\",\"license\":\"GPL-3.0\"},\"contracts/PoolTogether/twab/ObservationLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.15;\\n\\nimport {SafeCastLib} from \\\"../../Solbase/SafeCastLib.sol\\\";\\nimport \\\"./OverflowSafeComparatorLib.sol\\\";\\nimport \\\"./RingBufferLib.sol\\\";\\n\\n/**\\n * @title Observation Library\\n * @notice This library allows one to store an array of timestamped values and efficiently binary search them.\\n * @dev Largely pulled from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/c05a0e2c8c08c460fb4d05cfdda30b3ad8deeaac/contracts/libraries/Oracle.sol\\n * @author PoolTogether Inc.\\n */\\nlibrary ObservationLib {\\n  using OverflowSafeComparatorLib for uint32;\\n  using SafeCastLib for uint256;\\n\\n  /// @notice The maximum number of observations\\n  uint24 public constant MAX_CARDINALITY = 16777215; // 2**24\\n\\n  /**\\n   * @notice Observation, which includes an amount and timestamp.\\n   * @param amount `amount` at `timestamp`.\\n   * @param timestamp Recorded `timestamp`.\\n   */\\n  struct Observation {\\n    uint224 amount;\\n    uint32 timestamp;\\n  }\\n\\n  /**\\n   * @notice Fetches Observations `beforeOrAt` and `atOrAfter` a `_target`, eg: where [`beforeOrAt`, `atOrAfter`] is satisfied.\\n   * The result may be the same Observation, or adjacent Observations.\\n   * @dev The answer must be contained in the array used when the target is located within the stored Observation.\\n   * boundaries: older than the most recent Observation and younger, or the same age as, the oldest Observation.\\n   * @dev  If `_newestObservationIndex` is less than `_oldestObservationIndex`, it means that we've wrapped around the circular buffer.\\n   *       So the most recent observation will be at `_oldestObservationIndex + _cardinality - 1`, at the beginning of the circular buffer.\\n   * @param _observations List of Observations to search through.\\n   * @param _newestObservationIndex Index of the newest Observation. Right side of the circular buffer.\\n   * @param _oldestObservationIndex Index of the oldest Observation. Left side of the circular buffer.\\n   * @param _target Timestamp at which we are searching the Observation.\\n   * @param _cardinality Cardinality of the circular buffer we are searching through.\\n   * @param _time Timestamp at which we perform the binary search.\\n   * @return beforeOrAt Observation recorded before, or at, the target.\\n   * @return atOrAfter Observation recorded at, or after, the target.\\n   */\\n  function binarySearch(\\n    Observation[MAX_CARDINALITY] storage _observations,\\n    uint24 _newestObservationIndex,\\n    uint24 _oldestObservationIndex,\\n    uint32 _target,\\n    uint24 _cardinality,\\n    uint32 _time\\n  ) internal view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n    uint256 leftSide = _oldestObservationIndex;\\n    uint256 rightSide = _newestObservationIndex < leftSide\\n      ? leftSide + _cardinality - 1\\n      : _newestObservationIndex;\\n    uint256 currentIndex;\\n\\n    while (true) {\\n      // We start our search in the middle of the `leftSide` and `rightSide`.\\n      // After each iteration, we narrow down the search to the left or the right side while still starting our search in the middle.\\n      currentIndex = (leftSide + rightSide) / 2;\\n\\n      beforeOrAt = _observations[uint24(RingBufferLib.wrap(currentIndex, _cardinality))];\\n      uint32 beforeOrAtTimestamp = beforeOrAt.timestamp;\\n\\n      // We've landed on an uninitialized timestamp, keep searching higher (more recently).\\n      if (beforeOrAtTimestamp == 0) {\\n        leftSide = currentIndex + 1;\\n        continue;\\n      }\\n\\n      atOrAfter = _observations[uint24(RingBufferLib.nextIndex(currentIndex, _cardinality))];\\n\\n      bool targetAtOrAfter = beforeOrAtTimestamp.lte(_target, _time);\\n\\n      // Check if we've found the corresponding Observation.\\n      if (targetAtOrAfter && _target.lte(atOrAfter.timestamp, _time)) {\\n        break;\\n      }\\n\\n      // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower. To the left of the current index.\\n      if (!targetAtOrAfter) {\\n        rightSide = currentIndex - 1;\\n      } else {\\n        // Otherwise, we keep searching higher. To the left of the current index.\\n        leftSide = currentIndex + 1;\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xb21c32c47d51a96ed46021df0f6ef9f994cb47ffcd25079bd369f3fa254a22fa\",\"license\":\"GPL-3.0\"},\"contracts/PoolTogether/twab/OverflowSafeComparatorLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.15;\\n\\n/// @title OverflowSafeComparatorLib library to share comparator functions between contracts\\n/// @dev Code taken from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/3e88af408132fc957e3e406f65a0ce2b1ca06c3d/contracts/libraries/Oracle.sol\\n/// @author PoolTogether Inc.\\nlibrary OverflowSafeComparatorLib {\\n  /// @notice 32-bit timestamps comparator.\\n  /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\\n  /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\\n  /// @param _b Timestamp to compare against `_a`.\\n  /// @param _timestamp A timestamp truncated to 32 bits.\\n  /// @return bool Whether `_a` is chronologically < `_b`.\\n  function lt(\\n    uint32 _a,\\n    uint32 _b,\\n    uint32 _timestamp\\n  ) internal pure returns (bool) {\\n    // No need to adjust if there hasn't been an overflow\\n    if (_a <= _timestamp && _b <= _timestamp) return _a < _b;\\n\\n    uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\\n    uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\\n\\n    return aAdjusted < bAdjusted;\\n  }\\n\\n  /// @notice 32-bit timestamps comparator.\\n  /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.\\n  /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.\\n  /// @param _b Timestamp to compare against `_a`.\\n  /// @param _timestamp A timestamp truncated to 32 bits.\\n  /// @return bool Whether `_a` is chronologically <= `_b`.\\n  function lte(\\n    uint32 _a,\\n    uint32 _b,\\n    uint32 _timestamp\\n  ) internal pure returns (bool) {\\n    // No need to adjust if there hasn't been an overflow\\n    if (_a <= _timestamp && _b <= _timestamp) return _a <= _b;\\n\\n    uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\\n    uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\\n\\n    return aAdjusted <= bAdjusted;\\n  }\\n\\n  /// @notice 32-bit timestamp subtractor\\n  /// @dev safe for 0 or 1 overflows, where `_a` and `_b` must be chronologically before or equal to time\\n  /// @param _a The subtraction left operand\\n  /// @param _b The subtraction right operand\\n  /// @param _timestamp The current time.  Expected to be chronologically after both.\\n  /// @return The difference between a and b, adjusted for overflow\\n  function checkedSub(\\n    uint32 _a,\\n    uint32 _b,\\n    uint32 _timestamp\\n  ) internal pure returns (uint32) {\\n    // No need to adjust if there hasn't been an overflow\\n\\n    if (_a <= _timestamp && _b <= _timestamp) return _a - _b;\\n\\n    uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;\\n    uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;\\n\\n    return uint32(aAdjusted - bAdjusted);\\n  }\\n}\\n\",\"keccak256\":\"0x1070e687847b2295fd2e989beadeefbdcf2afe0e61fe959150acddb7052c0a6c\",\"license\":\"GPL-3.0\"},\"contracts/PoolTogether/twab/RingBufferLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.15;\\n\\nlibrary RingBufferLib {\\n  /**\\n   * @notice Returns wrapped TWAB index.\\n   * @dev  In order to navigate the TWAB circular buffer, we need to use the modulo operator.\\n   * @dev  For example, if `_index` is equal to 32 and the TWAB circular buffer is of `_cardinality` 32,\\n   *       it will return 0 and will point to the first element of the array.\\n   * @param _index Index used to navigate through the TWAB circular buffer.\\n   * @param _cardinality TWAB buffer cardinality.\\n   * @return TWAB index.\\n   */\\n  function wrap(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\\n    return _index % _cardinality;\\n  }\\n\\n  /**\\n   * @notice Computes the negative offset from the given index, wrapped by the cardinality.\\n   * @dev  We add `_cardinality` to `_index` to be able to offset even if `_amount` is superior to `_cardinality`.\\n   * @param _index The index from which to offset\\n   * @param _amount The number of indices to offset.  This is subtracted from the given index.\\n   * @param _cardinality The number of elements in the ring buffer\\n   * @return Offsetted index.\\n   */\\n  function offset(\\n    uint256 _index,\\n    uint256 _amount,\\n    uint256 _cardinality\\n  ) internal pure returns (uint256) {\\n    return wrap(_index + _cardinality - _amount, _cardinality);\\n  }\\n\\n  /// @notice Returns the index of the last recorded TWAB\\n  /// @param _nextIndex The next available twab index.  This will be recorded to next.\\n  /// @param _cardinality The cardinality of the TWAB history.\\n  /// @return The index of the last recorded TWAB\\n  function newestIndex(uint256 _nextIndex, uint256 _cardinality) internal pure returns (uint256) {\\n    if (_cardinality == 0) {\\n      return 0;\\n    }\\n\\n    return wrap(_nextIndex + _cardinality - 1, _cardinality);\\n  }\\n\\n  /// @notice Computes the ring buffer index that follows the given one, wrapped by cardinality\\n  /// @param _index The index to increment\\n  /// @param _cardinality The number of elements in the Ring Buffer\\n  /// @return The next index relative to the given index.  Will wrap around to 0 if the next index == cardinality\\n  function nextIndex(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {\\n    return wrap(_index + 1, _cardinality);\\n  }\\n}\\n\",\"keccak256\":\"0xfb81a85188bf9def399391777b3fa83dbc30e7cb2494560485ae45eb716ad830\",\"license\":\"GPL-3.0\"},\"contracts/PoolTogether/twab/TwabLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.15;\\n\\nimport \\\"./ExtendedSafeCastLib.sol\\\";\\nimport \\\"./OverflowSafeComparatorLib.sol\\\";\\nimport \\\"./RingBufferLib.sol\\\";\\nimport \\\"./ObservationLib.sol\\\";\\n\\n/**\\n  * @title  PoolTogether V4 TwabLib (Library)\\n  * @author PoolTogether Inc Team\\n  * @dev    Time-Weighted Average Balance Library for ERC20 tokens.\\n  * @notice This TwabLib adds on-chain historical lookups to a user(s) time-weighted average balance.\\n            Each user is mapped to an Account struct containing the TWAB history (ring buffer) and\\n            ring buffer parameters. Every token.transfer() creates a new TWAB checkpoint. The new TWAB\\n            checkpoint is stored in the circular ring buffer, as either a new checkpoint or rewriting\\n            a previous checkpoint with new parameters. The TwabLib (using existing blocktimes of 1block/15sec)\\n            guarantees minimum 7.4 years of search history.\\n */\\nlibrary TwabLib {\\n  using OverflowSafeComparatorLib for uint32;\\n  using ExtendedSafeCastLib for uint256;\\n\\n  /**\\n      * @notice Sets max ring buffer length in the Account.twabs Observation list.\\n                As users transfer/mint/burn tickets new Observation checkpoints are\\n                recorded. The current max cardinality guarantees a seven year minimum,\\n                of accurate historical lookups with current estimates of 1 new block\\n                every 15 seconds - assuming each block contains a transfer to trigger an\\n                observation write to storage.e\\n      * @dev    The user Account.AccountDetails.cardinality parameter can NOT exceed\\n                the max cardinality variable. Preventing \\\"corrupted\\\" ring buffer lookup\\n                pointers and new observation checkpoints.\\n\\n                The MAX_CARDINALITY in fact guarantees at least 7.4 years of records:\\n                If 14 = block time in seconds\\n                (2**24) * 14 = 234881024 seconds of history\\n                234881024 / (365 * 24 * 60 * 60) ~= 7.44 years\\n    */\\n  uint24 public constant MAX_CARDINALITY = 16777215; // 2**24\\n\\n  /** @notice Struct ring buffer parameters for single user Account\\n      * @param balance       Current balance for an Account\\n      * @param nextTwabIndex Next uninitialized or updatable ring buffer checkpoint storage slot\\n      * @param cardinality   Current total \\\"initialized\\\" ring buffer checkpoints for single user AccountDetails.\\n                             Used to set initial boundary conditions for an efficient binary search.\\n    */\\n  struct AccountDetails {\\n    uint208 balance;\\n    uint24 nextTwabIndex;\\n    uint24 cardinality;\\n  }\\n\\n  /// @notice Combines account details with their twab history\\n  /// @param details The account details\\n  /// @param twabs The history of twabs for this account\\n  struct Account {\\n    AccountDetails details;\\n    ObservationLib.Observation[MAX_CARDINALITY] twabs;\\n  }\\n\\n  /// @notice Increases an account's balance and records a new twab.\\n  /// @param _account The account whose balance will be increased\\n  /// @param _amount The amount to increase the balance by\\n  /// @param _currentTime The current time\\n  /// @return accountDetails The new AccountDetails\\n  /// @return twab The user's latest TWAB\\n  /// @return isNew Whether the TWAB is new\\n  function increaseBalance(\\n    Account storage _account,\\n    uint208 _amount,\\n    uint32 _currentTime\\n  )\\n    internal\\n    returns (\\n      AccountDetails memory accountDetails,\\n      ObservationLib.Observation memory twab,\\n      bool isNew\\n    )\\n  {\\n    AccountDetails memory _accountDetails = _account.details;\\n    (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);\\n    accountDetails.balance = _accountDetails.balance + _amount;\\n  }\\n\\n  /** @notice Calculates the next TWAB checkpoint for an account with a decreasing balance.\\n   * @dev    With Account struct and amount decreasing calculates the next TWAB observable checkpoint.\\n   * @param _account        Account whose balance will be decreased\\n   * @param _amount         Amount to decrease the balance by\\n   * @param _revertMessage  Revert message for insufficient balance\\n   * @return accountDetails Updated Account.details struct\\n   * @return twab           TWAB observation (with decreasing average)\\n   * @return isNew          Whether TWAB is new or calling twice in the same block\\n   */\\n  function decreaseBalance(\\n    Account storage _account,\\n    uint208 _amount,\\n    string memory _revertMessage,\\n    uint32 _currentTime\\n  )\\n    internal\\n    returns (\\n      AccountDetails memory accountDetails,\\n      ObservationLib.Observation memory twab,\\n      bool isNew\\n    )\\n  {\\n    AccountDetails memory _accountDetails = _account.details;\\n\\n    require(_accountDetails.balance >= _amount, _revertMessage);\\n\\n    (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);\\n    unchecked {\\n      accountDetails.balance -= _amount;\\n    }\\n  }\\n\\n  /** @notice Calculates the average balance held by a user for a given time frame.\\n      * @dev    Finds the average balance between start and end timestamp epochs.\\n                Validates the supplied end time is within the range of elapsed time i.e. less then timestamp of now.\\n      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer\\n      * @param _accountDetails User AccountDetails struct loaded in memory\\n      * @param _startTime      Start of timestamp range as an epoch\\n      * @param _endTime        End of timestamp range as an epoch\\n      * @param _currentTime    Block.timestamp\\n      * @return Average balance of user held between epoch timestamps start and end\\n    */\\n  function getAverageBalanceBetween(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails,\\n    uint32 _startTime,\\n    uint32 _endTime,\\n    uint32 _currentTime\\n  ) internal view returns (uint256) {\\n    uint32 endTime = _endTime > _currentTime ? _currentTime : _endTime;\\n\\n    return _getAverageBalanceBetween(_twabs, _accountDetails, _startTime, endTime, _currentTime);\\n  }\\n\\n  /// @notice Retrieves the oldest TWAB\\n  /// @param _twabs The storage array of twabs\\n  /// @param _accountDetails The TWAB account details\\n  /// @return index The index of the oldest TWAB in the twabs array\\n  /// @return twab The oldest TWAB\\n  function oldestTwab(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails\\n  ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {\\n    index = _accountDetails.nextTwabIndex;\\n    twab = _twabs[index];\\n\\n    // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0\\n    if (twab.timestamp == 0) {\\n      index = 0;\\n      twab = _twabs[0];\\n    }\\n  }\\n\\n  /// @notice Retrieves the newest TWAB\\n  /// @param _twabs The storage array of twabs\\n  /// @param _accountDetails The TWAB account details\\n  /// @return index The index of the newest TWAB in the twabs array\\n  /// @return twab The newest TWAB\\n  function newestTwab(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails\\n  ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {\\n    index = uint24(RingBufferLib.newestIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY));\\n    twab = _twabs[index];\\n  }\\n\\n  /// @notice Retrieves amount at `_targetTime` timestamp\\n  /// @param _twabs List of TWABs to search through.\\n  /// @param _accountDetails Accounts details\\n  /// @param _targetTime Timestamp at which the reserved TWAB should be for.\\n  /// @return uint256 TWAB amount at `_targetTime`.\\n  function getBalanceAt(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails,\\n    uint32 _targetTime,\\n    uint32 _currentTime\\n  ) internal view returns (uint256) {\\n    uint32 timeToTarget = _targetTime > _currentTime ? _currentTime : _targetTime;\\n    return _getBalanceAt(_twabs, _accountDetails, timeToTarget, _currentTime);\\n  }\\n\\n  /// @notice Calculates the average balance held by a user for a given time frame.\\n  /// @param _startTime The start time of the time frame.\\n  /// @param _endTime The end time of the time frame.\\n  /// @return The average balance that the user held during the time frame.\\n  function _getAverageBalanceBetween(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails,\\n    uint32 _startTime,\\n    uint32 _endTime,\\n    uint32 _currentTime\\n  ) private view returns (uint256) {\\n    (uint24 oldestTwabIndex, ObservationLib.Observation memory oldTwab) = oldestTwab(\\n      _twabs,\\n      _accountDetails\\n    );\\n\\n    (uint24 newestTwabIndex, ObservationLib.Observation memory newTwab) = newestTwab(\\n      _twabs,\\n      _accountDetails\\n    );\\n\\n    ObservationLib.Observation memory startTwab = _calculateTwab(\\n      _twabs,\\n      _accountDetails,\\n      newTwab,\\n      oldTwab,\\n      newestTwabIndex,\\n      oldestTwabIndex,\\n      _startTime,\\n      _currentTime\\n    );\\n\\n    ObservationLib.Observation memory endTwab = _calculateTwab(\\n      _twabs,\\n      _accountDetails,\\n      newTwab,\\n      oldTwab,\\n      newestTwabIndex,\\n      oldestTwabIndex,\\n      _endTime,\\n      _currentTime\\n    );\\n\\n    // Difference in amount / time\\n    return\\n      (endTwab.amount - startTwab.amount) /\\n      OverflowSafeComparatorLib.checkedSub(endTwab.timestamp, startTwab.timestamp, _currentTime);\\n  }\\n\\n  /** @notice Searches TWAB history and calculate the difference between amount(s)/timestamp(s) to return average balance\\n                between the Observations closes to the supplied targetTime.\\n      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer\\n      * @param _accountDetails User AccountDetails struct loaded in memory\\n      * @param _targetTime     Target timestamp to filter Observations in the ring buffer binary search\\n      * @param _currentTime    Block.timestamp\\n      * @return uint256 Time-weighted average amount between two closest observations.\\n    */\\n  function _getBalanceAt(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails,\\n    uint32 _targetTime,\\n    uint32 _currentTime\\n  ) private view returns (uint256) {\\n    uint24 newestTwabIndex;\\n    ObservationLib.Observation memory afterOrAt;\\n    ObservationLib.Observation memory beforeOrAt;\\n    (newestTwabIndex, beforeOrAt) = newestTwab(_twabs, _accountDetails);\\n\\n    // If `_targetTime` is chronologically after the newest TWAB, we can simply return the current balance\\n    if (beforeOrAt.timestamp.lte(_targetTime, _currentTime)) {\\n      return _accountDetails.balance;\\n    }\\n\\n    uint24 oldestTwabIndex;\\n    // Now, set before to the oldest TWAB\\n    (oldestTwabIndex, beforeOrAt) = oldestTwab(_twabs, _accountDetails);\\n\\n    // If `_targetTime` is chronologically before the oldest TWAB, we can early return\\n    if (_targetTime.lt(beforeOrAt.timestamp, _currentTime)) {\\n      return 0;\\n    }\\n\\n    // Otherwise, we perform the `binarySearch`\\n    (beforeOrAt, afterOrAt) = ObservationLib.binarySearch(\\n      _twabs,\\n      newestTwabIndex,\\n      oldestTwabIndex,\\n      _targetTime,\\n      _accountDetails.cardinality,\\n      _currentTime\\n    );\\n\\n    // Sum the difference in amounts and divide by the difference in timestamps.\\n    // The time-weighted average balance uses time measured between two epoch timestamps as\\n    // a constaint on the measurement when calculating the time weighted average balance.\\n    return\\n      (afterOrAt.amount - beforeOrAt.amount) /\\n      OverflowSafeComparatorLib.checkedSub(afterOrAt.timestamp, beforeOrAt.timestamp, _currentTime);\\n  }\\n\\n  /** @notice Calculates a user TWAB for a target timestamp using the historical TWAB records.\\n                The balance is linearly interpolated: amount differences / timestamp differences\\n                using the simple (after.amount - before.amount / end.timestamp - start.timestamp) formula.\\n    /** @dev    Binary search in _calculateTwab fails when searching out of bounds. Thus, before\\n                searching we exclude target timestamps out of range of newest/oldest TWAB(s).\\n                IF a search is before or after the range we \\\"extrapolate\\\" a Observation from the expected state.\\n      * @param _twabs           Individual user Observation recorded checkpoints passed as storage pointer\\n      * @param _accountDetails  User AccountDetails struct loaded in memory\\n      * @param _newestTwab      Newest TWAB in history (end of ring buffer)\\n      * @param _oldestTwab      Olderst TWAB in history (end of ring buffer)\\n      * @param _newestTwabIndex Pointer in ring buffer to newest TWAB\\n      * @param _oldestTwabIndex Pointer in ring buffer to oldest TWAB\\n      * @param _targetTimestamp Epoch timestamp to calculate for time (T) in the TWAB\\n      * @param _time            Block.timestamp\\n      * @return accountDetails Updated Account.details struct\\n    */\\n  function _calculateTwab(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails,\\n    ObservationLib.Observation memory _newestTwab,\\n    ObservationLib.Observation memory _oldestTwab,\\n    uint24 _newestTwabIndex,\\n    uint24 _oldestTwabIndex,\\n    uint32 _targetTimestamp,\\n    uint32 _time\\n  ) private view returns (ObservationLib.Observation memory) {\\n    // If `_targetTimestamp` is chronologically after the newest TWAB, we extrapolate a new one\\n    if (_newestTwab.timestamp.lt(_targetTimestamp, _time)) {\\n      return _computeNextTwab(_newestTwab, _accountDetails.balance, _targetTimestamp);\\n    }\\n\\n    if (_newestTwab.timestamp == _targetTimestamp) {\\n      return _newestTwab;\\n    }\\n\\n    if (_oldestTwab.timestamp == _targetTimestamp) {\\n      return _oldestTwab;\\n    }\\n\\n    // If `_targetTimestamp` is chronologically before the oldest TWAB, we create a zero twab\\n    if (_targetTimestamp.lt(_oldestTwab.timestamp, _time)) {\\n      return ObservationLib.Observation({ amount: 0, timestamp: _targetTimestamp });\\n    }\\n\\n    // Otherwise, both timestamps must be surrounded by twabs.\\n    (\\n      ObservationLib.Observation memory beforeOrAtStart,\\n      ObservationLib.Observation memory afterOrAtStart\\n    ) = ObservationLib.binarySearch(\\n        _twabs,\\n        _newestTwabIndex,\\n        _oldestTwabIndex,\\n        _targetTimestamp,\\n        _accountDetails.cardinality,\\n        _time\\n      );\\n\\n    uint224 heldBalance = (afterOrAtStart.amount - beforeOrAtStart.amount) /\\n      OverflowSafeComparatorLib.checkedSub(\\n        afterOrAtStart.timestamp,\\n        beforeOrAtStart.timestamp,\\n        _time\\n      );\\n\\n    return _computeNextTwab(beforeOrAtStart, heldBalance, _targetTimestamp);\\n  }\\n\\n  /**\\n   * @notice Calculates the next TWAB using the newestTwab and updated balance.\\n   * @dev    Storage of the TWAB obersation is managed by the calling function and not _computeNextTwab.\\n   * @param _currentTwab    Newest Observation in the Account.twabs list\\n   * @param _currentBalance User balance at time of most recent (newest) checkpoint write\\n   * @param _time           Current block.timestamp\\n   * @return TWAB Observation\\n   */\\n  function _computeNextTwab(\\n    ObservationLib.Observation memory _currentTwab,\\n    uint224 _currentBalance,\\n    uint32 _time\\n  ) private pure returns (ObservationLib.Observation memory) {\\n    // New twab amount = last twab amount (or zero) + (current amount * elapsed seconds)\\n    return\\n      ObservationLib.Observation({\\n        amount: _currentTwab.amount +\\n          _currentBalance *\\n          (_time.checkedSub(_currentTwab.timestamp, _time)),\\n        timestamp: _time\\n      });\\n  }\\n\\n  /// @notice Sets a new TWAB Observation at the next available index and returns the new account details.\\n  /// @dev Note that if _currentTime is before the last observation timestamp, it appears as an overflow\\n  /// @param _twabs The twabs array to insert into\\n  /// @param _accountDetails The current account details\\n  /// @param _currentTime The current time\\n  /// @return accountDetails The new account details\\n  /// @return twab The newest twab (may or may not be brand-new)\\n  /// @return isNew Whether the newest twab was created by this call\\n  function _nextTwab(\\n    ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,\\n    AccountDetails memory _accountDetails,\\n    uint32 _currentTime\\n  )\\n    private\\n    returns (\\n      AccountDetails memory accountDetails,\\n      ObservationLib.Observation memory twab,\\n      bool isNew\\n    )\\n  {\\n    (, ObservationLib.Observation memory _newestTwab) = newestTwab(_twabs, _accountDetails);\\n\\n    // if we're in the same block, return\\n    if (_newestTwab.timestamp == _currentTime) {\\n      return (_accountDetails, _newestTwab, false);\\n    }\\n\\n    ObservationLib.Observation memory newTwab = _computeNextTwab(\\n      _newestTwab,\\n      _accountDetails.balance,\\n      _currentTime\\n    );\\n\\n    _twabs[_accountDetails.nextTwabIndex] = newTwab;\\n\\n    AccountDetails memory nextAccountDetails = push(_accountDetails);\\n\\n    return (nextAccountDetails, newTwab, true);\\n  }\\n\\n  /// @notice \\\"Pushes\\\" a new element on the AccountDetails ring buffer, and returns the new AccountDetails\\n  /// @param _accountDetails The account details from which to pull the cardinality and next index\\n  /// @return The new AccountDetails\\n  function push(AccountDetails memory _accountDetails)\\n    internal\\n    pure\\n    returns (AccountDetails memory)\\n  {\\n    _accountDetails.nextTwabIndex = uint24(\\n      RingBufferLib.nextIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY)\\n    );\\n\\n    // Prevent the Account specific cardinality from exceeding the MAX_CARDINALITY.\\n    // The ring buffer length is limited by MAX_CARDINALITY. IF the account.cardinality\\n    // exceeds the max cardinality, new observations would be incorrectly set or the\\n    // observation would be out of \\\"bounds\\\" of the ring buffer. Once reached the\\n    // AccountDetails.cardinality will continue to be equal to max cardinality.\\n    if (_accountDetails.cardinality < MAX_CARDINALITY) {\\n      _accountDetails.cardinality += 1;\\n    }\\n\\n    return _accountDetails;\\n  }\\n}\\n\",\"keccak256\":\"0x0d01c49d0fd4689606b9455be00860ce1247b7b4cdd075d365a028d6340c15f3\",\"license\":\"GPL-3.0\"},\"contracts/Solbase/Base64.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode and decode strings in Base64.\\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(bytes memory data, bool fileSafe, bool noPadding) internal pure returns (string memory result) {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, sub(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0230)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n                    \\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n\\n                let r := mod(dataLength, 3)\\n\\n                switch noPadding\\n                case 0 {\\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n                    // Write the length of the string.\\n                    mstore(result, encodedLength)\\n                }\\n                default {\\n                    // Write the length of the string.\\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(end, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Decodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let end := add(data, dataLength)\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                switch and(dataLength, 3)\\n                case 0 {\\n                    // If padded.\\n                    decodedLength := sub(\\n                        decodedLength,\\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\\n                    )\\n                }\\n                default {\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                }\\n\\n                result := mload(0x40)\\n\\n                // Write the length of the string.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n\\n                    ptr := add(ptr, 3)\\n                    \\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 32 + 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\\n\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4728181da403b230b3066303df2e02da2e23358e79494aa0df7a1ddd98b2e869\",\"license\":\"MIT\"},\"contracts/Solbase/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas-optimized implementation of EIP-712 domain separator and digest encoding.\\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/EIP712.sol)\\nabstract contract EIP712 {\\n    /// -----------------------------------------------------------------------\\n    /// Domain Constants\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    bytes32 internal immutable HASHED_DOMAIN_NAME;\\n\\n    bytes32 internal immutable HASHED_DOMAIN_VERSION;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(string memory domainName, string memory version) {\\n        HASHED_DOMAIN_NAME = keccak256(bytes(domainName));\\n\\n        HASHED_DOMAIN_VERSION = keccak256(bytes(version));\\n\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// EIP-712 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(DOMAIN_TYPEHASH, HASHED_DOMAIN_NAME, HASHED_DOMAIN_VERSION, block.chainid, address(this))\\n            );\\n    }\\n\\n    function computeDigest(bytes32 hashStruct) internal view virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(), hashStruct));\\n    }\\n}\\n\",\"keccak256\":\"0xffb537f7470309a15ed68d23ceb590762ce018de65cebdae8a37e22a16c09403\",\"license\":\"MIT\"},\"contracts/Solbase/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Modern, minimalist, and gas-optimized ERC20 implementation.\\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC20/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20/ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Metadata Storage\\n    /// -----------------------------------------------------------------------\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC20 Storage\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC20 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Mint/Burn Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x38018638822193c49f53569b4dbc038d92025e95260277ef1346c563d05e1bd5\",\"license\":\"MIT\"},\"contracts/Solbase/ERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { ERC20 } from \\\"./ERC20.sol\\\";\\nimport { EIP712 } from \\\"./EIP712.sol\\\";\\n\\n/// @notice ERC20 + EIP-2612 implementation.\\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC20/extensions/ERC20Permit.sol)\\nabstract contract ERC20Permit is ERC20, EIP712 {\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error PermitExpired();\\n\\n    error InvalidSigner();\\n\\n    /// -----------------------------------------------------------------------\\n    /// EIP-2612 Constants\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// -----------------------------------------------------------------------\\n    /// EIP-2612 Storage\\n    /// -----------------------------------------------------------------------\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) ERC20(_name, _symbol, _decimals) EIP712(_name, \\\"1\\\") {}\\n\\n    /// -----------------------------------------------------------------------\\n    /// EIP-2612 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (block.timestamp > deadline) revert PermitExpired();\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                computeDigest(keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            if (recoveredAddress == address(0)) revert InvalidSigner();\\n\\n            if (recoveredAddress != owner) revert InvalidSigner();\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n}\\n\",\"keccak256\":\"0xa86945e5e14d7ff86c608df40c87f0f64e963190cbb811fba1a83b5bbf9e3fa7\",\"license\":\"MIT\"},\"contracts/Solbase/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/// @notice Modern, minimalist, and gas-optimized ERC721 implementation.\\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC721.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error NotMinted();\\n\\n    error ZeroAddress();\\n\\n    error NotApproved();\\n\\n    error WrongFrom();\\n\\n    error InvalidRecipient();\\n\\n    error UnsafeRecipient();\\n\\n    error AlreadyMinted();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Metadata Storage/Logic\\n    /// -----------------------------------------------------------------------\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC721 Balance/Owner Storage\\n    /// -----------------------------------------------------------------------\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        if ((owner = _ownerOf[id]) == address(0)) revert NotMinted();\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) revert ZeroAddress();\\n        return _balanceOf[owner];\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC721 Approval Storage\\n    /// -----------------------------------------------------------------------\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC721 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) revert NotApproved();\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        if (from != _ownerOf[id]) revert WrongFrom();\\n\\n        if (to == address(0)) revert InvalidRecipient();\\n\\n        if (msg.sender != from && !isApprovedForAll[from][msg.sender] && msg.sender != getApproved[id])\\n            revert NotApproved();\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC165 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Mint/Burn Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        if (to == address(0)) revert InvalidRecipient();\\n\\n        if (_ownerOf[id] != address(0)) revert AlreadyMinted();\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        if (owner == address(0)) revert NotMinted();\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Safe Mint Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n\\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\\n        _mint(to, id);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) !=\\n                ERC721TokenReceiver.onERC721Received.selector\\n            ) revert UnsafeRecipient();\\n        }\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/tokens/ERC721.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0xbfadbb1f311150496bd23053a8ed410a69bef6804dcb0aef28ba61c10824b77e\",\"license\":\"MIT\"},\"contracts/Solbase/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/auth/Owned.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error Unauthorized();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Ownership Storage\\n    /// -----------------------------------------------------------------------\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != owner) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Ownership Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xf0368e1996c0fcad13e23bcf261711339a3134eb0f3d59da06c52b86612c67a5\",\"license\":\"MIT\"},\"contracts/Solbase/OwnedRoles.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner and multiroles authorization mixin.\\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/auth/OwnedRoles.sol)\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/auth/OwnableRoles.sol)\\n/// @dev While the ownable portion follows EIP-173 (https://eips.ethereum.org/EIPS/eip-173)\\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\\n/// may be unique to this codebase.\\nabstract contract OwnedRoles {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev The `user`'s roles is updated to `roles`.\\n    /// Each bit of `roles` represents whether the role is set.\\n    event RolesUpdated(address indexed user, uint256 indexed roles);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /// @dev `keccak256(bytes(\\\"RolesUpdated(address,uint256)\\\"))`.\\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev The caller is not authorized to call the function.\\n    // error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev `bytes4(keccak256(bytes(\\\"Unauthorized()\\\")))`.\\n    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\\n\\n    /// @dev `bytes4(keccak256(bytes(\\\"NewOwnerIsZeroAddress()\\\")))`.\\n    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;\\n\\n    /// @dev `bytes4(keccak256(bytes(\\\"NoHandoverRequest()\\\")))`.\\n    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Storage\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally choosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    ///\\n    /// The role slot of `user` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\\n    ///     let roleSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// This automatically ignores the upper bits of the `user` in case\\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Functions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Grants the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn on.\\n    function _grantRoles(address user, uint256 roles) internal virtual {\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\\n            let roleSlot := keccak256(0x00, 0x20)\\n            // Load the current value and `or` it with `roles`.\\n            let newRoles := or(sload(roleSlot), roles)\\n            // Store the new value.\\n            sstore(roleSlot, newRoles)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\\n        }\\n    }\\n\\n    /// @dev Removes the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn off.\\n    function _removeRoles(address user, uint256 roles) internal virtual {\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\\n            let roleSlot := keccak256(0x00, 0x20)\\n            // Load the current value.\\n            let currentRoles := sload(roleSlot)\\n            // Use `and` to compute the intersection of `currentRoles` and `roles`,\\n            // `xor` it with `currentRoles` to flip the bits in the intersection.\\n            let newRoles := xor(currentRoles, and(currentRoles, roles))\\n            // Then, store the new value.\\n            sstore(roleSlot, newRoles)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Public Update Functions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Reverts if the `newOwner` is the zero address.\\n            if iszero(newOwner) {\\n                mstore(0x00, _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), newOwner)\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n        }\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        assembly {\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), 0)\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), 0)\\n        }\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\\n            assembly {\\n                // Compute and set the handover slot to 1.\\n                mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\\n                sstore(keccak256(0x00, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\\n            sstore(keccak256(0x00, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        assembly {\\n            // Clean the upper 96 bits.\\n            pendingOwner := shr(96, shl(96, pendingOwner))\\n            // Compute and set the handover slot to 0.\\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\\n            let handoverSlot := keccak256(0x00, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), pendingOwner)\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), pendingOwner)\\n        }\\n    }\\n\\n    /// @dev Allows the owner to grant `user` `roles`.\\n    /// If the `user` already has a role, then it will be an no-op for the role.\\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _grantRoles(user, roles);\\n    }\\n\\n    /// @dev Allows the owner to remove `user` `roles`.\\n    /// If the `user` does not have a role, then it will be an no-op for the role.\\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _removeRoles(user, roles);\\n    }\\n\\n    /// @dev Allow the caller to remove their own roles.\\n    /// If the caller does not have a role, then it will be an no-op for the role.\\n    function renounceRoles(uint256 roles) public payable virtual {\\n        _removeRoles(msg.sender, roles);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Public Read Functions\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner) public view virtual returns (uint256 result) {\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\\n            // Load the handover slot.\\n            result := sload(keccak256(0x00, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /// @dev Returns whether `user` has any of `roles`.\\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool result) {\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\\n            // Load the stored value, and set the result to whether the\\n            // `and` intersection of the value and `roles` is not zero.\\n            result := iszero(iszero(and(sload(keccak256(0x00, 0x20)), roles)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `user` has all of `roles`.\\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool result) {\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\\n            // Whether the stored value is contains all the set bits in `roles`.\\n            result := eq(and(sload(keccak256(0x00, 0x20)), roles), roles)\\n        }\\n    }\\n\\n    /// @dev Returns the roles of `user`.\\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\\n            // Load the stored value.\\n            roles := sload(keccak256(0x00, 0x20))\\n        }\\n    }\\n\\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    function rolesFromOrdinals(uint8[] memory ordinals) public pure returns (uint256 roles) {\\n        assembly {\\n            // Skip the length slot.\\n            let o := add(ordinals, 0x20)\\n            // `shl` 5 is equivalent to multiplying by 0x20.\\n            let end := add(o, shl(5, mload(ordinals)))\\n            // prettier-ignore\\n            for {} iszero(eq(o, end)) { o := add(o, 0x20) } {\\n                roles := or(roles, shl(and(mload(o), 0xff), 1))\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    function ordinalsFromRoles(uint256 roles) public pure returns (uint8[] memory ordinals) {\\n        assembly {\\n            // Grab the pointer to the free memory.\\n            let ptr := add(mload(0x40), 0x20)\\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\\n            // smaller bytecode, as this function is not meant to be called on-chain.\\n            // prettier-ignore\\n            for { let i := 0 } 1 { i := add(i, 1) } {\\n                mstore(ptr, i)\\n                // `shr` 5 is equivalent to multiplying by 0x20.\\n                // Push back into the ordinals array if the bit is set.\\n                ptr := add(ptr, shl(5, and(roles, 1)))\\n                roles := shr(1, roles)\\n                // prettier-ignore\\n                if iszero(roles) { break }\\n            }\\n            // Set `ordinals` to the start of the free memory.\\n            ordinals := mload(0x40)\\n            // Allocate the memory.\\n            mstore(0x40, ptr)\\n            // Store the length of `ordinals`.\\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Modifiers\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by an account with `roles`.\\n    modifier onlyRoles(uint256 roles) virtual {\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by the owner or by an account\\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\\n        assembly {\\n            // If the caller is not the stored owner.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                // Compute the role slot.\\n                mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\\n                // Load the stored value, and if the `and` intersection\\n                // of the value and `roles` is zero, revert.\\n                if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by an account with `roles`\\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\\n                // If the caller is not the stored owner.\\n                if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Role Constants\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 internal constant _ROLE_0 = 1 << 0;\\n    uint256 internal constant _ROLE_1 = 1 << 1;\\n    uint256 internal constant _ROLE_2 = 1 << 2;\\n    uint256 internal constant _ROLE_3 = 1 << 3;\\n    uint256 internal constant _ROLE_4 = 1 << 4;\\n    uint256 internal constant _ROLE_5 = 1 << 5;\\n    uint256 internal constant _ROLE_6 = 1 << 6;\\n    uint256 internal constant _ROLE_7 = 1 << 7;\\n    uint256 internal constant _ROLE_8 = 1 << 8;\\n    uint256 internal constant _ROLE_9 = 1 << 9;\\n    uint256 internal constant _ROLE_10 = 1 << 10;\\n    uint256 internal constant _ROLE_11 = 1 << 11;\\n    uint256 internal constant _ROLE_12 = 1 << 12;\\n    uint256 internal constant _ROLE_13 = 1 << 13;\\n    uint256 internal constant _ROLE_14 = 1 << 14;\\n    uint256 internal constant _ROLE_15 = 1 << 15;\\n    uint256 internal constant _ROLE_16 = 1 << 16;\\n    uint256 internal constant _ROLE_17 = 1 << 17;\\n    uint256 internal constant _ROLE_18 = 1 << 18;\\n    uint256 internal constant _ROLE_19 = 1 << 19;\\n    uint256 internal constant _ROLE_20 = 1 << 20;\\n    uint256 internal constant _ROLE_21 = 1 << 21;\\n    uint256 internal constant _ROLE_22 = 1 << 22;\\n    uint256 internal constant _ROLE_23 = 1 << 23;\\n    uint256 internal constant _ROLE_24 = 1 << 24;\\n    uint256 internal constant _ROLE_25 = 1 << 25;\\n    uint256 internal constant _ROLE_26 = 1 << 26;\\n    uint256 internal constant _ROLE_27 = 1 << 27;\\n    uint256 internal constant _ROLE_28 = 1 << 28;\\n    uint256 internal constant _ROLE_29 = 1 << 29;\\n    uint256 internal constant _ROLE_30 = 1 << 30;\\n    uint256 internal constant _ROLE_31 = 1 << 31;\\n    uint256 internal constant _ROLE_32 = 1 << 32;\\n    uint256 internal constant _ROLE_33 = 1 << 33;\\n    uint256 internal constant _ROLE_34 = 1 << 34;\\n    uint256 internal constant _ROLE_35 = 1 << 35;\\n    uint256 internal constant _ROLE_36 = 1 << 36;\\n    uint256 internal constant _ROLE_37 = 1 << 37;\\n    uint256 internal constant _ROLE_38 = 1 << 38;\\n    uint256 internal constant _ROLE_39 = 1 << 39;\\n    uint256 internal constant _ROLE_40 = 1 << 40;\\n    uint256 internal constant _ROLE_41 = 1 << 41;\\n    uint256 internal constant _ROLE_42 = 1 << 42;\\n    uint256 internal constant _ROLE_43 = 1 << 43;\\n    uint256 internal constant _ROLE_44 = 1 << 44;\\n    uint256 internal constant _ROLE_45 = 1 << 45;\\n    uint256 internal constant _ROLE_46 = 1 << 46;\\n    uint256 internal constant _ROLE_47 = 1 << 47;\\n    uint256 internal constant _ROLE_48 = 1 << 48;\\n    uint256 internal constant _ROLE_49 = 1 << 49;\\n    uint256 internal constant _ROLE_50 = 1 << 50;\\n    uint256 internal constant _ROLE_51 = 1 << 51;\\n    uint256 internal constant _ROLE_52 = 1 << 52;\\n    uint256 internal constant _ROLE_53 = 1 << 53;\\n    uint256 internal constant _ROLE_54 = 1 << 54;\\n    uint256 internal constant _ROLE_55 = 1 << 55;\\n    uint256 internal constant _ROLE_56 = 1 << 56;\\n    uint256 internal constant _ROLE_57 = 1 << 57;\\n    uint256 internal constant _ROLE_58 = 1 << 58;\\n    uint256 internal constant _ROLE_59 = 1 << 59;\\n    uint256 internal constant _ROLE_60 = 1 << 60;\\n    uint256 internal constant _ROLE_61 = 1 << 61;\\n    uint256 internal constant _ROLE_62 = 1 << 62;\\n    uint256 internal constant _ROLE_63 = 1 << 63;\\n    uint256 internal constant _ROLE_64 = 1 << 64;\\n    uint256 internal constant _ROLE_65 = 1 << 65;\\n    uint256 internal constant _ROLE_66 = 1 << 66;\\n    uint256 internal constant _ROLE_67 = 1 << 67;\\n    uint256 internal constant _ROLE_68 = 1 << 68;\\n    uint256 internal constant _ROLE_69 = 1 << 69;\\n    uint256 internal constant _ROLE_70 = 1 << 70;\\n    uint256 internal constant _ROLE_71 = 1 << 71;\\n    uint256 internal constant _ROLE_72 = 1 << 72;\\n    uint256 internal constant _ROLE_73 = 1 << 73;\\n    uint256 internal constant _ROLE_74 = 1 << 74;\\n    uint256 internal constant _ROLE_75 = 1 << 75;\\n    uint256 internal constant _ROLE_76 = 1 << 76;\\n    uint256 internal constant _ROLE_77 = 1 << 77;\\n    uint256 internal constant _ROLE_78 = 1 << 78;\\n    uint256 internal constant _ROLE_79 = 1 << 79;\\n    uint256 internal constant _ROLE_80 = 1 << 80;\\n    uint256 internal constant _ROLE_81 = 1 << 81;\\n    uint256 internal constant _ROLE_82 = 1 << 82;\\n    uint256 internal constant _ROLE_83 = 1 << 83;\\n    uint256 internal constant _ROLE_84 = 1 << 84;\\n    uint256 internal constant _ROLE_85 = 1 << 85;\\n    uint256 internal constant _ROLE_86 = 1 << 86;\\n    uint256 internal constant _ROLE_87 = 1 << 87;\\n    uint256 internal constant _ROLE_88 = 1 << 88;\\n    uint256 internal constant _ROLE_89 = 1 << 89;\\n    uint256 internal constant _ROLE_90 = 1 << 90;\\n    uint256 internal constant _ROLE_91 = 1 << 91;\\n    uint256 internal constant _ROLE_92 = 1 << 92;\\n    uint256 internal constant _ROLE_93 = 1 << 93;\\n    uint256 internal constant _ROLE_94 = 1 << 94;\\n    uint256 internal constant _ROLE_95 = 1 << 95;\\n    uint256 internal constant _ROLE_96 = 1 << 96;\\n    uint256 internal constant _ROLE_97 = 1 << 97;\\n    uint256 internal constant _ROLE_98 = 1 << 98;\\n    uint256 internal constant _ROLE_99 = 1 << 99;\\n    uint256 internal constant _ROLE_100 = 1 << 100;\\n    uint256 internal constant _ROLE_101 = 1 << 101;\\n    uint256 internal constant _ROLE_102 = 1 << 102;\\n    uint256 internal constant _ROLE_103 = 1 << 103;\\n    uint256 internal constant _ROLE_104 = 1 << 104;\\n    uint256 internal constant _ROLE_105 = 1 << 105;\\n    uint256 internal constant _ROLE_106 = 1 << 106;\\n    uint256 internal constant _ROLE_107 = 1 << 107;\\n    uint256 internal constant _ROLE_108 = 1 << 108;\\n    uint256 internal constant _ROLE_109 = 1 << 109;\\n    uint256 internal constant _ROLE_110 = 1 << 110;\\n    uint256 internal constant _ROLE_111 = 1 << 111;\\n    uint256 internal constant _ROLE_112 = 1 << 112;\\n    uint256 internal constant _ROLE_113 = 1 << 113;\\n    uint256 internal constant _ROLE_114 = 1 << 114;\\n    uint256 internal constant _ROLE_115 = 1 << 115;\\n    uint256 internal constant _ROLE_116 = 1 << 116;\\n    uint256 internal constant _ROLE_117 = 1 << 117;\\n    uint256 internal constant _ROLE_118 = 1 << 118;\\n    uint256 internal constant _ROLE_119 = 1 << 119;\\n    uint256 internal constant _ROLE_120 = 1 << 120;\\n    uint256 internal constant _ROLE_121 = 1 << 121;\\n    uint256 internal constant _ROLE_122 = 1 << 122;\\n    uint256 internal constant _ROLE_123 = 1 << 123;\\n    uint256 internal constant _ROLE_124 = 1 << 124;\\n    uint256 internal constant _ROLE_125 = 1 << 125;\\n    uint256 internal constant _ROLE_126 = 1 << 126;\\n    uint256 internal constant _ROLE_127 = 1 << 127;\\n    uint256 internal constant _ROLE_128 = 1 << 128;\\n    uint256 internal constant _ROLE_129 = 1 << 129;\\n    uint256 internal constant _ROLE_130 = 1 << 130;\\n    uint256 internal constant _ROLE_131 = 1 << 131;\\n    uint256 internal constant _ROLE_132 = 1 << 132;\\n    uint256 internal constant _ROLE_133 = 1 << 133;\\n    uint256 internal constant _ROLE_134 = 1 << 134;\\n    uint256 internal constant _ROLE_135 = 1 << 135;\\n    uint256 internal constant _ROLE_136 = 1 << 136;\\n    uint256 internal constant _ROLE_137 = 1 << 137;\\n    uint256 internal constant _ROLE_138 = 1 << 138;\\n    uint256 internal constant _ROLE_139 = 1 << 139;\\n    uint256 internal constant _ROLE_140 = 1 << 140;\\n    uint256 internal constant _ROLE_141 = 1 << 141;\\n    uint256 internal constant _ROLE_142 = 1 << 142;\\n    uint256 internal constant _ROLE_143 = 1 << 143;\\n    uint256 internal constant _ROLE_144 = 1 << 144;\\n    uint256 internal constant _ROLE_145 = 1 << 145;\\n    uint256 internal constant _ROLE_146 = 1 << 146;\\n    uint256 internal constant _ROLE_147 = 1 << 147;\\n    uint256 internal constant _ROLE_148 = 1 << 148;\\n    uint256 internal constant _ROLE_149 = 1 << 149;\\n    uint256 internal constant _ROLE_150 = 1 << 150;\\n    uint256 internal constant _ROLE_151 = 1 << 151;\\n    uint256 internal constant _ROLE_152 = 1 << 152;\\n    uint256 internal constant _ROLE_153 = 1 << 153;\\n    uint256 internal constant _ROLE_154 = 1 << 154;\\n    uint256 internal constant _ROLE_155 = 1 << 155;\\n    uint256 internal constant _ROLE_156 = 1 << 156;\\n    uint256 internal constant _ROLE_157 = 1 << 157;\\n    uint256 internal constant _ROLE_158 = 1 << 158;\\n    uint256 internal constant _ROLE_159 = 1 << 159;\\n    uint256 internal constant _ROLE_160 = 1 << 160;\\n    uint256 internal constant _ROLE_161 = 1 << 161;\\n    uint256 internal constant _ROLE_162 = 1 << 162;\\n    uint256 internal constant _ROLE_163 = 1 << 163;\\n    uint256 internal constant _ROLE_164 = 1 << 164;\\n    uint256 internal constant _ROLE_165 = 1 << 165;\\n    uint256 internal constant _ROLE_166 = 1 << 166;\\n    uint256 internal constant _ROLE_167 = 1 << 167;\\n    uint256 internal constant _ROLE_168 = 1 << 168;\\n    uint256 internal constant _ROLE_169 = 1 << 169;\\n    uint256 internal constant _ROLE_170 = 1 << 170;\\n    uint256 internal constant _ROLE_171 = 1 << 171;\\n    uint256 internal constant _ROLE_172 = 1 << 172;\\n    uint256 internal constant _ROLE_173 = 1 << 173;\\n    uint256 internal constant _ROLE_174 = 1 << 174;\\n    uint256 internal constant _ROLE_175 = 1 << 175;\\n    uint256 internal constant _ROLE_176 = 1 << 176;\\n    uint256 internal constant _ROLE_177 = 1 << 177;\\n    uint256 internal constant _ROLE_178 = 1 << 178;\\n    uint256 internal constant _ROLE_179 = 1 << 179;\\n    uint256 internal constant _ROLE_180 = 1 << 180;\\n    uint256 internal constant _ROLE_181 = 1 << 181;\\n    uint256 internal constant _ROLE_182 = 1 << 182;\\n    uint256 internal constant _ROLE_183 = 1 << 183;\\n    uint256 internal constant _ROLE_184 = 1 << 184;\\n    uint256 internal constant _ROLE_185 = 1 << 185;\\n    uint256 internal constant _ROLE_186 = 1 << 186;\\n    uint256 internal constant _ROLE_187 = 1 << 187;\\n    uint256 internal constant _ROLE_188 = 1 << 188;\\n    uint256 internal constant _ROLE_189 = 1 << 189;\\n    uint256 internal constant _ROLE_190 = 1 << 190;\\n    uint256 internal constant _ROLE_191 = 1 << 191;\\n    uint256 internal constant _ROLE_192 = 1 << 192;\\n    uint256 internal constant _ROLE_193 = 1 << 193;\\n    uint256 internal constant _ROLE_194 = 1 << 194;\\n    uint256 internal constant _ROLE_195 = 1 << 195;\\n    uint256 internal constant _ROLE_196 = 1 << 196;\\n    uint256 internal constant _ROLE_197 = 1 << 197;\\n    uint256 internal constant _ROLE_198 = 1 << 198;\\n    uint256 internal constant _ROLE_199 = 1 << 199;\\n    uint256 internal constant _ROLE_200 = 1 << 200;\\n    uint256 internal constant _ROLE_201 = 1 << 201;\\n    uint256 internal constant _ROLE_202 = 1 << 202;\\n    uint256 internal constant _ROLE_203 = 1 << 203;\\n    uint256 internal constant _ROLE_204 = 1 << 204;\\n    uint256 internal constant _ROLE_205 = 1 << 205;\\n    uint256 internal constant _ROLE_206 = 1 << 206;\\n    uint256 internal constant _ROLE_207 = 1 << 207;\\n    uint256 internal constant _ROLE_208 = 1 << 208;\\n    uint256 internal constant _ROLE_209 = 1 << 209;\\n    uint256 internal constant _ROLE_210 = 1 << 210;\\n    uint256 internal constant _ROLE_211 = 1 << 211;\\n    uint256 internal constant _ROLE_212 = 1 << 212;\\n    uint256 internal constant _ROLE_213 = 1 << 213;\\n    uint256 internal constant _ROLE_214 = 1 << 214;\\n    uint256 internal constant _ROLE_215 = 1 << 215;\\n    uint256 internal constant _ROLE_216 = 1 << 216;\\n    uint256 internal constant _ROLE_217 = 1 << 217;\\n    uint256 internal constant _ROLE_218 = 1 << 218;\\n    uint256 internal constant _ROLE_219 = 1 << 219;\\n    uint256 internal constant _ROLE_220 = 1 << 220;\\n    uint256 internal constant _ROLE_221 = 1 << 221;\\n    uint256 internal constant _ROLE_222 = 1 << 222;\\n    uint256 internal constant _ROLE_223 = 1 << 223;\\n    uint256 internal constant _ROLE_224 = 1 << 224;\\n    uint256 internal constant _ROLE_225 = 1 << 225;\\n    uint256 internal constant _ROLE_226 = 1 << 226;\\n    uint256 internal constant _ROLE_227 = 1 << 227;\\n    uint256 internal constant _ROLE_228 = 1 << 228;\\n    uint256 internal constant _ROLE_229 = 1 << 229;\\n    uint256 internal constant _ROLE_230 = 1 << 230;\\n    uint256 internal constant _ROLE_231 = 1 << 231;\\n    uint256 internal constant _ROLE_232 = 1 << 232;\\n    uint256 internal constant _ROLE_233 = 1 << 233;\\n    uint256 internal constant _ROLE_234 = 1 << 234;\\n    uint256 internal constant _ROLE_235 = 1 << 235;\\n    uint256 internal constant _ROLE_236 = 1 << 236;\\n    uint256 internal constant _ROLE_237 = 1 << 237;\\n    uint256 internal constant _ROLE_238 = 1 << 238;\\n    uint256 internal constant _ROLE_239 = 1 << 239;\\n    uint256 internal constant _ROLE_240 = 1 << 240;\\n    uint256 internal constant _ROLE_241 = 1 << 241;\\n    uint256 internal constant _ROLE_242 = 1 << 242;\\n    uint256 internal constant _ROLE_243 = 1 << 243;\\n    uint256 internal constant _ROLE_244 = 1 << 244;\\n    uint256 internal constant _ROLE_245 = 1 << 245;\\n    uint256 internal constant _ROLE_246 = 1 << 246;\\n    uint256 internal constant _ROLE_247 = 1 << 247;\\n    uint256 internal constant _ROLE_248 = 1 << 248;\\n    uint256 internal constant _ROLE_249 = 1 << 249;\\n    uint256 internal constant _ROLE_250 = 1 << 250;\\n    uint256 internal constant _ROLE_251 = 1 << 251;\\n    uint256 internal constant _ROLE_252 = 1 << 252;\\n    uint256 internal constant _ROLE_253 = 1 << 253;\\n    uint256 internal constant _ROLE_254 = 1 << 254;\\n    uint256 internal constant _ROLE_255 = 1 << 255;\\n}\\n\",\"keccak256\":\"0x9a174f585097033c17843eaf24157314ba5ddb8d5f3facd0b79a29cadad2d23a\",\"license\":\"MIT\"},\"contracts/Solbase/OwnedThreeStep.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Three-step single owner authorization mixin.\\n/// @author SolBase (https://github.com/Sol-DAO/Solbase/blob/main/src/auth/OwnedThreeStep.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract OwnedThreeStep {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event OwnerUpdateInitiated(address indexed user, address indexed ownerCandidate);\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error Unauthorized();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Ownership Storage\\n    /// -----------------------------------------------------------------------\\n\\n    address public owner;\\n\\n    address internal _ownerCandidate;\\n\\n    bool internal _ownerCandidateConfirmed;\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != owner) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Create contract and set `owner`.\\n    /// @param _owner The `owner` of contract.\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Ownership Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Initiate ownership transfer.\\n    /// @param newOwner The `_ownerCandidate` that will `confirmOwner()`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        _ownerCandidate = newOwner;\\n\\n        emit OwnerUpdateInitiated(msg.sender, newOwner);\\n    }\\n\\n    /// @notice Confirm ownership between `owner` and `_ownerCandidate`.\\n    function confirmOwner() public payable virtual {\\n        if (_ownerCandidateConfirmed) {\\n            if (msg.sender != owner) revert Unauthorized();\\n\\n            delete _ownerCandidateConfirmed;\\n\\n            address newOwner = _ownerCandidate;\\n\\n            owner = newOwner;\\n\\n            emit OwnershipTransferred(msg.sender, newOwner);\\n        } else {\\n            if (msg.sender != _ownerCandidate) revert Unauthorized();\\n\\n            _ownerCandidateConfirmed = true;\\n        }\\n    }\\n\\n    /// @notice Terminate ownership by `owner`.\\n    function renounceOwner() public payable virtual onlyOwner {\\n        delete owner;\\n\\n        emit OwnershipTransferred(msg.sender, address(0));\\n    }\\n}\\n\",\"keccak256\":\"0x0e17d31793938b7361f24eccec66234f57a11155e1e33aa0e9c26f4c49cf1b6b\",\"license\":\"MIT\"},\"contracts/Solbase/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\nlibrary SafeCastLib {\\n    error OverFlow();\\n\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        if (x >= (1 << 248)) revert OverFlow();\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        if (x >= (1 << 224)) revert OverFlow();\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        if (x >= (1 << 192)) revert OverFlow();\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        if (x >= (1 << 160)) revert OverFlow();\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        if (x >= (1 << 128)) revert OverFlow();\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        if (x >= (1 << 96)) revert OverFlow();\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        if (x >= (1 << 64)) revert OverFlow();\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        if (x >= (1 << 32)) revert OverFlow();\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        if (x >= (1 << 24)) revert OverFlow();\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\\n        if (x >= (1 << 16)) revert OverFlow();\\n\\n        y = uint16(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        if (x >= (1 << 8)) revert OverFlow();\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0xf542a49fd453a358a7866a4362222adf78d0f4caf92c2be48f0ae298e8fcfa18\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052662386f26fc1000060035534801561001b57600080fd5b5060405161071738038061071783398101604081905261003a916100d1565b600080546001600160a01b0319166001600160a01b03851690811782556040518592907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350600180546001600160a01b039384166001600160a01b0319918216179091556002805492909316911617905550610114565b80516001600160a01b03811681146100cc57600080fd5b919050565b6000806000606084860312156100e657600080fd5b6100ef846100b5565b92506100fd602085016100b5565b915061010b604085016100b5565b90509250925092565b6105f4806101236000396000f3fe60806040526004361061007b5760003560e01c80638da5cb5b1161004e5780638da5cb5b1461011e578063a3df94471461013e578063f009cec814610151578063f2fde38b1461017157600080fd5b80631c5a9d9c1461008057806325eb5073146100a257806337bdc99b146100c25780636795a874146100e2575b600080fd5b34801561008c57600080fd5b506100a061009b3660046104e3565b610184565b005b3480156100ae57600080fd5b506100a06100bd366004610505565b6101f8565b3480156100ce57600080fd5b506100a06100dd366004610505565b610227565b3480156100ee57600080fd5b50600154610102906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b34801561012a57600080fd5b50600054610102906001600160a01b031681565b6100a061014c36600461052f565b6102fa565b34801561015d57600080fd5b50600254610102906001600160a01b031681565b6100a061017f3660046104e3565b610452565b6001546040516335313c2160e11b81526001600160a01b03838116600483015290911690636a627842906024016020604051808303816000875af11580156101d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101f49190610572565b5050565b6000546001600160a01b03163314610222576040516282b42960e81b815260040160405180910390fd5b600355565b6000546001600160a01b03163314610251576040516282b42960e81b815260040160405180910390fd5b604051600090339083908381818185875af1925050503d8060008114610293576040519150601f19603f3d011682016040523d82523d6000602084013e610298565b606091505b50509050806101f45760405162461bcd60e51b8152602060048201526024808201527f5765623343617264416374697661746f723a6574682d72656c656173652d66616044820152631a5b195960e21b60648201526084015b60405180910390fd5b6001610306828461058b565b60ff161061036b5760035434101561036b5760405162461bcd60e51b815260206004820152602260248201527f5765623343617264416374697661746f723a696e73756666696369656e742d656044820152610e8d60f31b60648201526084016102f1565b6001546040516335313c2160e11b81526001600160a01b0385811660048301526000921690636a627842906024016020604051808303816000875af11580156103b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103dc9190610572565b60025460405163066a9c8f60e11b81526004810183905260ff8087166024830152851660448201529192506001600160a01b031690630cd5391e90606401600060405180830381600087803b15801561043457600080fd5b505af1158015610448573d6000803e3d6000fd5b5050505050505050565b6000546001600160a01b0316331461047c576040516282b42960e81b815260040160405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b80356001600160a01b03811681146104de57600080fd5b919050565b6000602082840312156104f557600080fd5b6104fe826104c7565b9392505050565b60006020828403121561051757600080fd5b5035919050565b803560ff811681146104de57600080fd5b60008060006060848603121561054457600080fd5b61054d846104c7565b925061055b6020850161051e565b91506105696040850161051e565b90509250925092565b60006020828403121561058457600080fd5b5051919050565b600060ff821660ff84168060ff038211156105b657634e487b7160e01b600052601160045260246000fd5b01939250505056fea2646970667358221220b04a9e61ce11adf16fee627336be5bf23f3e9e7a9c001c1fff9e7ca311ed10c864736f6c634300080f0033",
  "deployedBytecode": "0x60806040526004361061007b5760003560e01c80638da5cb5b1161004e5780638da5cb5b1461011e578063a3df94471461013e578063f009cec814610151578063f2fde38b1461017157600080fd5b80631c5a9d9c1461008057806325eb5073146100a257806337bdc99b146100c25780636795a874146100e2575b600080fd5b34801561008c57600080fd5b506100a061009b3660046104e3565b610184565b005b3480156100ae57600080fd5b506100a06100bd366004610505565b6101f8565b3480156100ce57600080fd5b506100a06100dd366004610505565b610227565b3480156100ee57600080fd5b50600154610102906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b34801561012a57600080fd5b50600054610102906001600160a01b031681565b6100a061014c36600461052f565b6102fa565b34801561015d57600080fd5b50600254610102906001600160a01b031681565b6100a061017f3660046104e3565b610452565b6001546040516335313c2160e11b81526001600160a01b03838116600483015290911690636a627842906024016020604051808303816000875af11580156101d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101f49190610572565b5050565b6000546001600160a01b03163314610222576040516282b42960e81b815260040160405180910390fd5b600355565b6000546001600160a01b03163314610251576040516282b42960e81b815260040160405180910390fd5b604051600090339083908381818185875af1925050503d8060008114610293576040519150601f19603f3d011682016040523d82523d6000602084013e610298565b606091505b50509050806101f45760405162461bcd60e51b8152602060048201526024808201527f5765623343617264416374697661746f723a6574682d72656c656173652d66616044820152631a5b195960e21b60648201526084015b60405180910390fd5b6001610306828461058b565b60ff161061036b5760035434101561036b5760405162461bcd60e51b815260206004820152602260248201527f5765623343617264416374697661746f723a696e73756666696369656e742d656044820152610e8d60f31b60648201526084016102f1565b6001546040516335313c2160e11b81526001600160a01b0385811660048301526000921690636a627842906024016020604051808303816000875af11580156103b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103dc9190610572565b60025460405163066a9c8f60e11b81526004810183905260ff8087166024830152851660448201529192506001600160a01b031690630cd5391e90606401600060405180830381600087803b15801561043457600080fd5b505af1158015610448573d6000803e3d6000fd5b5050505050505050565b6000546001600160a01b0316331461047c576040516282b42960e81b815260040160405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b80356001600160a01b03811681146104de57600080fd5b919050565b6000602082840312156104f557600080fd5b6104fe826104c7565b9392505050565b60006020828403121561051757600080fd5b5035919050565b803560ff811681146104de57600080fd5b60008060006060848603121561054457600080fd5b61054d846104c7565b925061055b6020850161051e565b91506105696040850161051e565b90509250925092565b60006020828403121561058457600080fd5b5051919050565b600060ff821660ff84168060ff038211156105b657634e487b7160e01b600052601160045260246000fd5b01939250505056fea2646970667358221220b04a9e61ce11adf16fee627336be5bf23f3e9e7a9c001c1fff9e7ca311ed10c864736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "errors": {
      "Unauthorized()": [
        {
          "notice": "----------------------------------------------------------------------- Custom Errors -----------------------------------------------------------------------"
        }
      ]
    },
    "events": {
      "OwnershipTransferred(address,address)": {
        "notice": "----------------------------------------------------------------------- Events -----------------------------------------------------------------------"
      }
    },
    "kind": "user",
    "methods": {
      "owner()": {
        "notice": "----------------------------------------------------------------------- Ownership Storage -----------------------------------------------------------------------"
      },
      "transferOwnership(address)": {
        "notice": "----------------------------------------------------------------------- Ownership Logic -----------------------------------------------------------------------"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12571,
        "contract": "contracts/CardActivator.sol:CardActivator",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 1490,
        "contract": "contracts/CardActivator.sol:CardActivator",
        "label": "erc721KInstance",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 1492,
        "contract": "contracts/CardActivator.sol:CardActivator",
        "label": "erc721KDesignInstance",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 1495,
        "contract": "contracts/CardActivator.sol:CardActivator",
        "label": "STYLE_UPGRADE_VALUE",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}