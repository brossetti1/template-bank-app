{
  "address": "0x9d038Bdb6CefaD60451c9F816aa94eFfa9452E93",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "input",
          "type": "bytes"
        }
      ],
      "name": "fetch",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x158ffa28f6fb4e1852b03685ce3518185fceb7f65d92dad669896a2c91bc338f",
  "receipt": {
    "to": null,
    "from": "0x8C46e53dC60EC32e8DD67Fb11f076fF3EcDc5211",
    "contractAddress": "0x9d038Bdb6CefaD60451c9F816aa94eFfa9452E93",
    "transactionIndex": 22,
    "gasUsed": "561191",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000001000000000000200000000000000000000000120000000000000000000800000000000000000000000000040000400000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x59981f22fd789e7c32484a548f36b41131e84d3e7d0f201abbea03ef22bd65d9",
    "transactionHash": "0x158ffa28f6fb4e1852b03685ce3518185fceb7f65d92dad669896a2c91bc338f",
    "logs": [
      {
        "transactionIndex": 22,
        "blockNumber": 3472115,
        "transactionHash": "0x158ffa28f6fb4e1852b03685ce3518185fceb7f65d92dad669896a2c91bc338f",
        "address": "0x9d038Bdb6CefaD60451c9F816aa94eFfa9452E93",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000008c46e53dc60ec32e8dd67fb11f076ff3ecdc5211"
        ],
        "data": "0x",
        "logIndex": 28,
        "blockHash": "0x59981f22fd789e7c32484a548f36b41131e84d3e7d0f201abbea03ef22bd65d9"
      }
    ],
    "blockNumber": 3472115,
    "cumulativeGasUsed": "2435332",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "404f5463dd6ebc8ff1a6e382af5684f3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"name\":\"fetch\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Kames Geraghty\",\"kind\":\"dev\",\"methods\":{},\"title\":\"CardTraits\",\"version\":1},\"userdoc\":{\"errors\":{\"Unauthorized()\":[{\"notice\":\"----------------------------------------------------------------------- Custom Errors -----------------------------------------------------------------------\"}]},\"events\":{\"OwnershipTransferred(address,address)\":{\"notice\":\"----------------------------------------------------------------------- Events -----------------------------------------------------------------------\"}},\"kind\":\"user\",\"methods\":{\"owner()\":{\"notice\":\"----------------------------------------------------------------------- Ownership Storage -----------------------------------------------------------------------\"},\"transferOwnership(address)\":{\"notice\":\"----------------------------------------------------------------------- Ownership Logic -----------------------------------------------------------------------\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/CardTraits.sol\":\"CardTraits\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/CardTraits.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\nimport { Owned } from \\\"./Solbase/Owned.sol\\\";\\nimport { LibString } from \\\"./Solbase/LibString.sol\\\";\\nimport { IStream } from \\\"./ERC721K/interfaces/IStream.sol\\\";\\nimport { ITraitsFetch } from \\\"./ERC721K/interfaces/ITraitsFetch.sol\\\";\\n\\n/**\\n * @title CardTraits\\n * @author Kames Geraghty\\n */\\ncontract CardTraits is ITraitsFetch, Owned {\\n  constructor() Owned(msg.sender) {}\\n\\n\\n  /* ===================================================================================== */\\n  /* External Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function fetch(bytes memory input) external view returns (string memory) {\\n    (\\n      address account,\\n      address asset,\\n      uint256 balance,\\n      uint256 chance,\\n      uint256 avgBalance2Weeks,\\n      uint256 avgBalance8Weeks,\\n      uint256 avgBalance26Weeks,\\n      uint256 avgBalance52Weeks,\\n      string memory emoji,\\n      bytes32 color\\n    ) = abi.decode(\\n        input,\\n        (address, address, uint256, uint256, uint256, uint256, uint256, uint256, string, bytes32)\\n      );\\n\\n    string memory _account = LibString.toHexString(uint256(uint160(account)), 20);\\n    string memory _asset = LibString.toHexString(uint256(uint160(asset)), 20);\\n\\n    return\\n      string.concat(\\n        _generateTrait(\\\"owner\\\", _account),\\n        \\\",\\\",\\n        _generateTrait(\\\"asset\\\", _asset),\\n        \\\",\\\",\\n        _generateTrait(\\\"balance\\\", LibString.toString(balance)),\\n        \\\",\\\",\\n        _generateTrait(\\\"chance\\\", LibString.toString(chance)),\\n        \\\",\\\",\\n        _generateTrait(\\\"avgBalance2Weeks\\\", LibString.toString(avgBalance2Weeks)),\\n        \\\",\\\",\\n        _generateTrait(\\\"avgBalance8Weeks\\\", LibString.toString(avgBalance8Weeks)),\\n        \\\",\\\",\\n        _generateTrait(\\\"avgBalance26Weeks\\\", LibString.toString(avgBalance26Weeks)),\\n        \\\",\\\",\\n        _generateTrait(\\\"avgBalance52Weeks\\\", LibString.toString(avgBalance52Weeks)),\\n        \\\",\\\",\\n        _generateTrait(\\\"emoji\\\", emoji)\\n      );\\n  }\\n\\n  /* ===================================================================================== */\\n  /* Internal Functions                                                                    */\\n  /* ===================================================================================== */\\n\\n  function _generateTrait(string memory _key, string memory _value)\\n    internal\\n    pure\\n    returns (string memory __traits)\\n  {\\n    return string.concat('{\\\"trait_type\\\":' '\\\"', _key, '\\\",', '\\\"value\\\":', '\\\"', _value, '\\\"}');\\n  }\\n\\n  function _generateTraits(string[] memory _keys, string[] memory _values)\\n    internal\\n    pure\\n    returns (string memory __traits)\\n  {\\n    string memory _traits = \\\"\\\";\\n    for (uint256 i = 0; i < _keys.length; i++) {\\n      if (bytes(_values[i]).length > 0) {\\n        _traits = string.concat(_traits, _generateTrait(_keys[i], _values[i]), \\\",\\\");\\n      }\\n    }\\n    return _traits;\\n  }\\n}\\n\",\"keccak256\":\"0xff5cf434aed1b004d45aa326b141df115986accff176f324f840f3539a4b0c19\",\"license\":\"GPL-3.0\"},\"contracts/ERC721K/interfaces/IStream.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\ninterface IStream {\\n  function count(address _address) external view returns (uint256);\\n\\n  function getData(address _address)\\n    external\\n    view\\n    returns (string[] memory keys, string[] memory values);\\n\\n  function getValue(address _address, string memory _key) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xe0b5b0ba6414345934de73e26b35cbe1d69b82a0623fd52ebf81376dd3bb9b3a\",\"license\":\"MIT\"},\"contracts/ERC721K/interfaces/ITraitsFetch.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\ninterface ITraitsFetch {\\n  function fetch(bytes memory input) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x8454d6dcf4c798032b7459026b6fa23f586b76400175a27c9b100c1aca36c5a9\",\"license\":\"MIT\"},\"contracts/Solbase/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author SolDAO (https://github.com/Sol-DAO/Solbase/blob/main/src/utils/LibString.sol)\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constants\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\\n\\n    /// -----------------------------------------------------------------------\\n    /// Decimal Operations\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Hexadecimal Operations\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for {} 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            let m := add(start, 0xa0)\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\\n            // and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\\n            str := add(start, 0x60)\\n\\n            // Allocate the memory.\\n            mstore(0x40, str)\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let length := 20\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 32)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, 42)\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Other String Operations\\n    /// -----------------------------------------------------------------------\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\\n    function replace(\\n        string memory subject,\\n        string memory search,\\n        string memory replacement\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of \\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        // prettier-ignore\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            // prettier-ignore\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            // Zeroize the slot after the string.\\n            let last := add(add(result, 0x20), k)\\n            mstore(last, 0)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n            // Store the length of the result.\\n            mstore(result, k)\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(\\n        string memory subject,\\n        string memory search,\\n        uint256 from\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    // `result = min(from, subjectLength)`.\\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)    \\n                \\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(add(search, 0x20))\\n\\n                // prettier-ignore\\n                if iszero(lt(subject, subjectSearchEnd)) { break }\\n\\n                if iszero(lt(searchLength, 32)) {\\n                    // prettier-ignore\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        // prettier-ignore\\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\\n                    }\\n                    break\\n                }\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(\\n        string memory subject,\\n        string memory search,\\n        uint256 from\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for {} 1 {} {\\n                let searchLength := mload(search)\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) {\\n                    from := fromMax\\n                }\\n                if iszero(mload(search)) {\\n                    result := from\\n                    break\\n                }\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\\n\\n                subject := add(add(subject, 0x20), from)\\n                // prettier-ignore\\n                if iszero(gt(subject, subjectSearchEnd)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                // prettier-ignore\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(subjectSearchEnd, 1))\\n                        break\\n                    }\\n                    subject := sub(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    // prettier-ignore\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        // prettier-ignore\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    // prettier-ignore\\n                    if iszero(times) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(output, 0)\\n                // Store the length.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(\\n        string memory subject,\\n        uint256 start,\\n        uint256 end\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) {\\n                end := subjectLength\\n            }\\n            if iszero(gt(subjectLength, start)) {\\n                start := subjectLength\\n            }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                // Copy the `subject` one word at a time, backwards.\\n                // prettier-ignore\\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := sub(o, 0x20)\\n                    // prettier-ignore\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of \\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        assembly {\\n            if mload(indices) {\\n                let indexPtr := add(indices, 0x20)\\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n                mstore(sub(indicesEnd, 0x20), mload(subject))\\n                mstore(indices, add(mload(indices), 1))\\n                let prevIndex := 0\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let index := mload(indexPtr)\\n                    mstore(indexPtr, 0x60)                        \\n                    if iszero(eq(index, prevIndex)) {\\n                        let element := mload(0x40)\\n                        let elementLength := sub(index, prevIndex)\\n                        mstore(element, elementLength)\\n                        // Copy the `subject` one word at a time, backwards.\\n                        // prettier-ignore\\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                            o := sub(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(o) { break }\\n                        }\\n                        // Zeroize the slot after the string.\\n                        mstore(add(add(element, 0x20), elementLength), 0)\\n                        // Allocate memory for the length and the bytes,\\n                        // rounded up to a multiple of 32.\\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\\n                        // Store the `element` into the array.\\n                        mstore(indexPtr, element)                        \\n                    }\\n                    prevIndex := add(index, mload(delimiter))\\n                    indexPtr := add(indexPtr, 0x20)\\n                    // prettier-ignore\\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\\n                }\\n                result := indices\\n                if iszero(mload(delimiter)) {\\n                    result := add(indices, 0x20)\\n                    mstore(result, sub(mload(indices), 2))\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\\n        assembly {\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, mload(a))\\n            // Copy `b` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes.\\n                mload(add(a, 0x1f)),\\n                // `length != 0 && length < 32`. Abuses underflow.\\n                // Assumes that the length is valid and within the block gas limit.\\n                lt(sub(mload(a), 1), 0x1f)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes of `a` and `b`.\\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                // Assumes that the lengths are valid and within the block gas limit.\\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(add(a, 0x20), mload(a)), 0)\\n            // Store the return offset.\\n            // Assumes that the string does not start from the scratch space.\\n            mstore(sub(a, 0x20), 0x20)\\n            // End the transaction, returning the string.\\n            return(sub(a, 0x20), add(mload(a), 0x40))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f6691a53736c5ddcbd6dfb3341ea124f7f01ed32f9bb22c4990a615fc598bc9\",\"license\":\"MIT\"},\"contracts/Solbase/Owned.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solbase (https://github.com/Sol-DAO/Solbase/blob/main/src/auth/Owned.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error Unauthorized();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Ownership Storage\\n    /// -----------------------------------------------------------------------\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != owner) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Ownership Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xf0368e1996c0fcad13e23bcf261711339a3134eb0f3d59da06c52b86612c67a5\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50600080546001600160a01b031916339081178255604051909182917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a3506108bd806100616000396000f3fe6080604052600436106100345760003560e01c80638da5cb5b14610039578063f2fde38b14610076578063f6559a6b1461008b575b600080fd5b34801561004557600080fd5b50600054610059906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b610089610084366004610491565b6100b8565b005b34801561009757600080fd5b506100ab6100a6366004610524565b61012d565b60405161006d91906105d4565b6000546001600160a01b031633146100e2576040516282b42960e81b815260040160405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b60606000806000806000806000806000808b8060200190518101906101529190610607565b9950995099509950995099509950995099509950600061017c8b6001600160a01b03166014610377565b905060006101948b6001600160a01b03166014610377565b90506101bd6040518060400160405280600581526020016437bbb732b960d91b81525083610409565b6101e460405180604001604052806005815260200164185cdcd95d60da1b81525083610409565b6102156040518060400160405280600781526020016662616c616e636560c81b8152506102108e610435565b610409565b610240604051806040016040528060068152602001656368616e636560d01b8152506102108e610435565b6102756040518060400160405280601081526020016f61766742616c616e6365325765656b7360801b8152506102108e610435565b6102aa6040518060400160405280601081526020016f61766742616c616e6365385765656b7360801b8152506102108e610435565b6102e06040518060400160405280601181526020017061766742616c616e636532365765656b7360781b8152506102108e610435565b6103166040518060400160405280601181526020017061766742616c616e636535325765656b7360781b8152506102108e610435565b61033d60405180604001604052806005815260200164656d6f6a6960d81b8152508d610409565b6040516020016103559998979695949392919061070a565b6040516020818303038152906040529c50505050505050505050505050919050565b60408051601f196062600185901b01811690910191829052600091019081526f30313233343536373839616263646566600f5280835b600f8116516001198401936000190153600f8160041c165183536000199093019260081c836103ad5780156103ea57632194895a6000526004601cfd5b50613078601f1983015281900360020160211990910190815292915050565b6060828260405160200161041e929190610804565b604051602081830303815290604052905092915050565b606060a06040510180604052602081039150506000815280825b600183039250600a81066030018353600a90048061044f5750819003601f19909101908152919050565b6001600160a01b038116811461048e57600080fd5b50565b6000602082840312156104a357600080fd5b81356104ae81610479565b9392505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156104f4576104f46104b5565b604052919050565b600067ffffffffffffffff821115610516576105166104b5565b50601f01601f191660200190565b60006020828403121561053657600080fd5b813567ffffffffffffffff81111561054d57600080fd5b8201601f8101841361055e57600080fd5b803561057161056c826104fc565b6104cb565b81815285602083850101111561058657600080fd5b81602084016020830137600091810160200191909152949350505050565b60005b838110156105bf5781810151838201526020016105a7565b838111156105ce576000848401525b50505050565b60208152600082518060208401526105f38160408501602087016105a4565b601f01601f19169190910160400192915050565b6000806000806000806000806000806101408b8d03121561062757600080fd5b8a5161063281610479565b60208c0151909a5061064381610479565b8099505060408b0151975060608b0151965060808b0151955060a08b0151945060c08b0151935060e08b015192506101008b015167ffffffffffffffff81111561068c57600080fd5b8b01601f81018d1361069d57600080fd5b80516106ab61056c826104fc565b8181528e60208385010111156106c057600080fd5b6106d18260208301602086016105a4565b8094505050506101208b015190509295989b9194979a5092959850565b600081516107008185602086016105a4565b9290920192915050565b60008a5161071c818460208f016105a4565b600b60fa1b9083019081528a5161073a816001840160208f016105a4565b600b60fa1b60019290910191820152895161075c816002840160208e016105a4565b600b60fa1b60029290910191820152885161077e816003840160208d016105a4565b0161078f60038201600b60fa1b9052565b61079c60048201896106ee565b600b60fa1b815290506107b260018201886106ee565b600b60fa1b815290506107c860018201876106ee565b600b60fa1b815290506107de60018201866106ee565b600b60fa1b815290506107f460018201856106ee565b9c9b505050505050505050505050565b6e3d913a3930b4ba2fba3cb832911d1160891b8152825160009061082f81600f8501602088016105a4565b61088b60f21b600f9184019182015267113b30b63ab2911d60c11b6011820152601160f91b6019820152835161086c81601a8401602088016105a4565b61227d60f01b601a9290910191820152601c0194935050505056fea2646970667358221220985dc185bc0989884e9a92f81fb03c5d867cb137639886973a5b641a4f799b5164736f6c634300080f0033",
  "deployedBytecode": "0x6080604052600436106100345760003560e01c80638da5cb5b14610039578063f2fde38b14610076578063f6559a6b1461008b575b600080fd5b34801561004557600080fd5b50600054610059906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b610089610084366004610491565b6100b8565b005b34801561009757600080fd5b506100ab6100a6366004610524565b61012d565b60405161006d91906105d4565b6000546001600160a01b031633146100e2576040516282b42960e81b815260040160405180910390fd5b600080546001600160a01b0319166001600160a01b0383169081178255604051909133917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b60606000806000806000806000806000808b8060200190518101906101529190610607565b9950995099509950995099509950995099509950600061017c8b6001600160a01b03166014610377565b905060006101948b6001600160a01b03166014610377565b90506101bd6040518060400160405280600581526020016437bbb732b960d91b81525083610409565b6101e460405180604001604052806005815260200164185cdcd95d60da1b81525083610409565b6102156040518060400160405280600781526020016662616c616e636560c81b8152506102108e610435565b610409565b610240604051806040016040528060068152602001656368616e636560d01b8152506102108e610435565b6102756040518060400160405280601081526020016f61766742616c616e6365325765656b7360801b8152506102108e610435565b6102aa6040518060400160405280601081526020016f61766742616c616e6365385765656b7360801b8152506102108e610435565b6102e06040518060400160405280601181526020017061766742616c616e636532365765656b7360781b8152506102108e610435565b6103166040518060400160405280601181526020017061766742616c616e636535325765656b7360781b8152506102108e610435565b61033d60405180604001604052806005815260200164656d6f6a6960d81b8152508d610409565b6040516020016103559998979695949392919061070a565b6040516020818303038152906040529c50505050505050505050505050919050565b60408051601f196062600185901b01811690910191829052600091019081526f30313233343536373839616263646566600f5280835b600f8116516001198401936000190153600f8160041c165183536000199093019260081c836103ad5780156103ea57632194895a6000526004601cfd5b50613078601f1983015281900360020160211990910190815292915050565b6060828260405160200161041e929190610804565b604051602081830303815290604052905092915050565b606060a06040510180604052602081039150506000815280825b600183039250600a81066030018353600a90048061044f5750819003601f19909101908152919050565b6001600160a01b038116811461048e57600080fd5b50565b6000602082840312156104a357600080fd5b81356104ae81610479565b9392505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156104f4576104f46104b5565b604052919050565b600067ffffffffffffffff821115610516576105166104b5565b50601f01601f191660200190565b60006020828403121561053657600080fd5b813567ffffffffffffffff81111561054d57600080fd5b8201601f8101841361055e57600080fd5b803561057161056c826104fc565b6104cb565b81815285602083850101111561058657600080fd5b81602084016020830137600091810160200191909152949350505050565b60005b838110156105bf5781810151838201526020016105a7565b838111156105ce576000848401525b50505050565b60208152600082518060208401526105f38160408501602087016105a4565b601f01601f19169190910160400192915050565b6000806000806000806000806000806101408b8d03121561062757600080fd5b8a5161063281610479565b60208c0151909a5061064381610479565b8099505060408b0151975060608b0151965060808b0151955060a08b0151945060c08b0151935060e08b015192506101008b015167ffffffffffffffff81111561068c57600080fd5b8b01601f81018d1361069d57600080fd5b80516106ab61056c826104fc565b8181528e60208385010111156106c057600080fd5b6106d18260208301602086016105a4565b8094505050506101208b015190509295989b9194979a5092959850565b600081516107008185602086016105a4565b9290920192915050565b60008a5161071c818460208f016105a4565b600b60fa1b9083019081528a5161073a816001840160208f016105a4565b600b60fa1b60019290910191820152895161075c816002840160208e016105a4565b600b60fa1b60029290910191820152885161077e816003840160208d016105a4565b0161078f60038201600b60fa1b9052565b61079c60048201896106ee565b600b60fa1b815290506107b260018201886106ee565b600b60fa1b815290506107c860018201876106ee565b600b60fa1b815290506107de60018201866106ee565b600b60fa1b815290506107f460018201856106ee565b9c9b505050505050505050505050565b6e3d913a3930b4ba2fba3cb832911d1160891b8152825160009061082f81600f8501602088016105a4565b61088b60f21b600f9184019182015267113b30b63ab2911d60c11b6011820152601160f91b6019820152835161086c81601a8401602088016105a4565b61227d60f01b601a9290910191820152601c0194935050505056fea2646970667358221220985dc185bc0989884e9a92f81fb03c5d867cb137639886973a5b641a4f799b5164736f6c634300080f0033",
  "devdoc": {
    "author": "Kames Geraghty",
    "kind": "dev",
    "methods": {},
    "title": "CardTraits",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "Unauthorized()": [
        {
          "notice": "----------------------------------------------------------------------- Custom Errors -----------------------------------------------------------------------"
        }
      ]
    },
    "events": {
      "OwnershipTransferred(address,address)": {
        "notice": "----------------------------------------------------------------------- Events -----------------------------------------------------------------------"
      }
    },
    "kind": "user",
    "methods": {
      "owner()": {
        "notice": "----------------------------------------------------------------------- Ownership Storage -----------------------------------------------------------------------"
      },
      "transferOwnership(address)": {
        "notice": "----------------------------------------------------------------------- Ownership Logic -----------------------------------------------------------------------"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12571,
        "contract": "contracts/CardTraits.sol:CardTraits",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      }
    }
  }
}